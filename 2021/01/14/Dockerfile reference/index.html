<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
  <script type="text/javascript">
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'UA-xxxxxx-xx');
  </script>
  

  <!-- Baidu Tongji -->
  
  <script type="text/javascript">
    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  

  <!-- Baidu Push -->
  
  <script>
    (function() {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>
  

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc" />
  <meta name="baidu-site-verification" content="PpzM9WxOJU" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="It&#39;s an IT blog..." />
  <meta name="keyword" content="v-vincen,IT  blog,Blog" />
  <link rel="shortcut icon" href="/img/avatar/roguerabbit.jpg" />

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>
  <!-- Bootstrap Core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css" />

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/beantech.min.css" />

  <!-- Pygments Highlight CSS -->
  
<link rel="stylesheet" href="../../../../css/highlight.css">
<link rel="stylesheet" href="../../../../css/widget.css">
<link rel="stylesheet" href="../../../../css/rocket.css">
<link rel="stylesheet" href="../../../../css/signature.css">
<link rel="stylesheet" href="../../../../css/catalog.css">
<link rel="stylesheet" href="../../../../css/livemylife.css">


  
  <!-- wave start -->
  <link rel="stylesheet" href="/css/wave.css" />
  <!-- wave end -->
  

  
  <!-- top start (article top hot config) -->
  <link rel="stylesheet" href="/css/top.css" />
  <!-- top end -->
  

  
  <!-- ThemeColor start -->
  <link rel="stylesheet" href="/css/scroll.css" />
  <!-- ThemeColor end -->
  

  
  <!-- viewer start (Picture preview) -->
  <link rel="stylesheet" href="/css/viewer.min.css" />
  <!-- viewer end -->
  

  
  <!-- Search start -->
  <link rel="stylesheet" href="/css/search.css" />
  <!-- Search end -->
  

  
  <!-- ThemeColor start -->
  <link rel="stylesheet" href="/css/themecolor.css" />
  <!-- ThemeColor end -->
  

  

  
  <!-- gitalk start -->
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
  <link rel="stylesheet" href="/css/gitalk.css" />
  <!-- gitalk end -->
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
    href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="https://wangpaitech.github.io/2021/01/14/Dockerfile reference/">
  <title>
    
    Dockerfile reference 中英文 - Andy&#39;s Blog
    
  </title>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->

<body ontouchstart="" class="body--home">
	<!-- ThemeColor -->
	
	<!-- ThemeColor -->
<!-- <div class="toggle" onclick="document.body.classList.toggle('body--dark')">Switch Color</div> -->

<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons bright-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>

	

	<!-- Gitter -->
	
	<!-- Gitter -->
<!-- Docs:https://gitter.im/?utm_source=left-menu-logo -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'your-community/your-room'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

	

	<!-- Navigation (contains search)-->
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">And&#39;s Blog</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">Home</a>
          </li>

          

          
          

          
          <li>
            <a href="/about/">About</a>
          </li>
          
          

          
          <li>
            <a href="/archive/">Archives</a>
          </li>
          
          

          
          <li>
            <a href="/categories/">Categories</a>
          </li>
          
          

          
          <li>
            <a href="/tags/">Tags</a>
          </li>
          
          

          
          <li><a class="popup-trigger" title="Search"><span class="search-icon"></span>Search</a></li>
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>


<script>
  // Drop Bootstarp low-performance Navbar
  // Use customize navbar with high-quality material design animation
  // in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


	<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    header.intro-header {
       /*post*/
        background-image: url('/img/header_img/lml_bg.jpg');
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/vincent-white.png');
      }
    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#Docker" title="Docker">Docker</a>
              
            </div>
            <h1>Dockerfile reference 中英文</h1>
            <h2 class="subheading">Dockerfile</h2>
            <span class="meta">
              Posted by Chen Jianfei on
              2021-01-14
            </span>


            
            <!-- WordCount start -->
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">133</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">27.7k</span> In Total
            </span>
            <div class="blank_box"></div>
            <!-- 不蒜子统计 start -->
            <span class="meta">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            <!-- WordCount end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



	<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
	<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <h1 id="Dockerfile-reference"><a href="#Dockerfile-reference" class="headerlink" title="Dockerfile reference"></a>Dockerfile reference</h1><h1 id="文档参考"><a href="#文档参考" class="headerlink" title="文档参考"></a>文档参考</h1><p><em>Estimated reading time: 81 minutes</em></p>
<p>预计阅读时间: 81分钟</p>
<p>Docker can build images automatically by reading the instructions from a <code>Dockerfile</code>. A <code>Dockerfile</code> is a text document that contains all the commands a user could call on the command line to assemble an image. Using <code>docker build</code> users can create an automated build that executes several command-line instructions in succession.</p>
<p>可以通过读取 Dockerfile 中的指令自动生成图像。 Dockerfile 是一个文本文档，其中包含用户可以在命令行上调用的所有命令来组装图像。 使用 docker 构建用户可以创建一个自动构建，连续执行多个命令行指令。(4)</p>
<p>This page describes the commands you can use in a <code>Dockerfile</code>. When you are done reading this page, refer to the <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener"><code>Dockerfile</code> Best Practices</a> for a tip-oriented guide.</p>
<p>这个页面描述了可以在 Dockerfile 中使用的命令。 当你读完这一页后，请参考 Dockerfile 最佳实践，以获得一个面向提示的指南。</p>
<h2 id="Usage-用法"><a href="#Usage-用法" class="headerlink" title="Usage 用法"></a>Usage 用法</h2><p>The <a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">docker build</a> command builds an image from a <code>Dockerfile</code> and a <em>context</em>. The build’s context is the set of files at a specified location <code>PATH</code> or <code>URL</code>. The <code>PATH</code> is a directory on your local filesystem. The <code>URL</code> is a Git repository location.</p>
<p>Docker build 命令根据 Dockerfile 和上下文构建一个映像。 构建的上下文是位于指定位置 PATH 或 URL 的文件集。 Path 是本地文件系统上的一个目录。 Url 是一个 Git 存储库位置。</p>
<p>A context is processed recursively. So, a <code>PATH</code> includes any subdirectories and the <code>URL</code> includes the repository and its submodules. This example shows a build command that uses the current directory as context:</p>
<p>上下文是递归处理的。因此，PATH 包括所有子目录，URL 包括存储库及其子模块。这个例子展示了一个使用工作目录作为上下文的 build 命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build .</span></span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>The build is run by the Docker daemon, not by the CLI. The first thing a build process does is send the entire context (recursively) to the daemon. In most cases, it’s best to start with an empty directory as context and keep your Dockerfile in that directory. Add only the files needed for building the Dockerfile.</p>
<p>构建由 Docker 守护进程运行，而不是由 CLI 运行。构建过程要做的第一件事是将整个上下文(递归地)发送到守护进程。在大多数情况下，最好从一个空目录作为上下文开始，并将 Dockerfile 保存在该目录中。只添加构建 Dockerfile 所需的文件。</p>
<blockquote>
<p><strong>Warning</strong></p>
<p>警告</p>
<p>Do not use your root directory, <code>/</code>, as the <code>PATH</code> as it causes the build to transfer the entire contents of your hard drive to the Docker daemon.</p>
<p>不要使用根目录/，因为 PATH 会导致构建将硬盘驱动器的全部内容传输到 Docker 守护进程。</p>
</blockquote>
<p>To use a file in the build context, the <code>Dockerfile</code> refers to the file specified in an instruction, for example, a <code>COPY</code> instruction. To increase the build’s performance, exclude files and directories by adding a <code>.dockerignore</code> file to the context directory. For information about how to <a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" target="_blank" rel="noopener">create a <code>.dockerignore</code> file</a> see the documentation on this page.</p>
<p>要在构建上下文中使用文件，Dockerfile 引用指令中指定的文件，例如 COPY 指令。若要提高生成的性能，请通过添加。将 dockerignore 文件移到上下文目录。有关如何创建。Dockerignore 文件查看这个页面上的文档。</p>
<p>Traditionally, the <code>Dockerfile</code> is called <code>Dockerfile</code> and located in the root of the context. You use the <code>-f</code> flag with <code>docker build</code> to point to a Dockerfile anywhere in your file system.</p>
<p>传统上，Dockerfile 被称为 Dockerfile，并且位于语境的根部。在 docker 构建中使用-f 标志指向文件系统中的任何位置的 Dockerfile。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -f /path/to/a/Dockerfile .</span></span><br></pre></td></tr></table></figure>

<p>You can specify a repository and tag at which to save the new image if the build succeeds:</p>
<p>如果构建成功，你可以指定一个存储库和标签来保存新映像:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t shykes/myapp .</span></span><br></pre></td></tr></table></figure>

<p>To tag the image into multiple repositories after the build, add multiple <code>-t</code> parameters when you run the <code>build</code> command:</p>
<p>要在构建之后将图像标记为多个存储库，请在运行构建命令时添加 multiple-t 参数:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span></span><br></pre></td></tr></table></figure>

<p>Before the Docker daemon runs the instructions in the <code>Dockerfile</code>, it performs a preliminary validation of the <code>Dockerfile</code> and returns an error if the syntax is incorrect:</p>
<p>在 Docker 守护进程运行 Dockerfile 中的指令之前，它会对 Dockerfile 进行初步验证，如果语法不正确，则返回一个错误:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t <span class="built_in">test</span>/myapp .</span></span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure>

<p>The Docker daemon runs the instructions in the <code>Dockerfile</code> one-by-one, committing the result of each instruction to a new image if necessary, before finally outputting the ID of your new image. The Docker daemon will automatically clean up the context you sent.</p>
<p>Docker 守护进程逐条运行 Dockerfile 中的指令，在最终输出新映像的 ID 之前，必要时将每条指令的结果提交到新映像中。Docker 守护进程将自动清除您发送的上下文。</p>
<p>Note that each instruction is run independently, and causes a new image to be created - so <code>RUN cd /tmp</code> will not have any effect on the next instructions.</p>
<p>请注意，每条指令都是独立运行的，并且会创建一个新映像——因此 RUN cd/tmp 不会对下一条指令产生任何影响。</p>
<p>Whenever possible, Docker will re-use the intermediate images (cache), to accelerate the <code>docker build</code> process significantly. This is indicated by the <code>Using cache</code> message in the console output. (For more information, see the <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener"><code>Dockerfile</code> best practices guide</a>:</p>
<p>只要有可能，Docker 将重用中间映像(缓存) ，以显著加快 Docker 构建过程。控制台输出中的 Using cache 消息指示了这一点。(有关更多信息，请参见 Dockerfile 最佳实践指南:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t svendowideit/ambassador .</span></span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1/4 : FROM alpine:3.2</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 31f630c65071</span></span><br><span class="line">Step 2/4 : MAINTAINER SvenDowideit@home.org.au</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Using cache</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 2a1c91448f5f</span></span><br><span class="line">Step 3/4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r /var/cache/</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Using cache</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 21ed6e7fbb73</span></span><br><span class="line">Step 4/4 : CMD env | grep _TCP= | (sed 's/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/' &amp;&amp; echo wait) | sh</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Using cache</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 7ea8aef582cc</span></span><br><span class="line">Successfully built 7ea8aef582cc</span><br></pre></td></tr></table></figure>

<p>Build cache is only used from images that have a local parent chain. This means that these images were created by previous builds or the whole chain of images was loaded with <code>docker load</code>. If you wish to use build cache of a specific image you can specify it with <code>--cache-from</code> option. Images specified with <code>--cache-from</code> do not need to have a parent chain and may be pulled from other registries.</p>
<p>生成缓存仅用于具有本地父级链的映像。这意味着这些图像是通过以前的构建创建的，或者整个图像链加载了 docker 加载。如果希望使用特定映像的构建缓存，可以使用 – cache-from 选项指定它。使用 – cache-from 指定的映像不需要有父链，可以从其他注册表中提取。</p>
<p>When you’re done with your build, you’re ready to look into <a href="https://docs.docker.com/engine/tutorials/dockerrepos/#/contributing-to-docker-hub" target="_blank" rel="noopener"><em>Pushing a repository to its registry</em></a>.</p>
<p>完成构建后，就可以考虑将存储库推送到其注册中心。</p>
<h2 id="BuildKit"><a href="#BuildKit" class="headerlink" title="BuildKit"></a>BuildKit</h2><p>Starting with version 18.09, Docker supports a new backend for executing your builds that is provided by the <a href="https://github.com/moby/buildkit" target="_blank" rel="noopener">moby/buildkit</a> project. The BuildKit backend provides many benefits compared to the old implementation. For example, BuildKit can:</p>
<p>从版本18.09开始，Docker 支持一个新的后端来执行 moby/buildkit 项目提供的构建。与旧的实现相比，BuildKit 后端提供了许多好处。例如，BuildKit 可以:</p>
<ul>
<li>Detect and skip executing unused build stages 检测并跳过执行未使用的构建阶段</li>
<li>Parallelize building independent build stages 建筑独立构建阶段的并行化</li>
<li>Incrementally transfer only the changed files in your build context between builds 在生成之间以增量方式传输生成上下文中已更改的文件</li>
<li>Detect and skip transferring unused files in your build context 检测并跳过在生成上下文中传输未使用的文件</li>
<li>Use external Dockerfile implementations with many new features 使用具有许多新特性的外部 Dockerfile 实现</li>
<li>Avoid side-effects with rest of the API (intermediate images and containers) 避免与 API 的其余部分(中间图像和容器)产生副作用</li>
<li>Prioritize your build cache for automatic pruning 优先考虑您的构建缓存，以实现自动清除</li>
</ul>
<p>To use the BuildKit backend, you need to set an environment variable <code>DOCKER_BUILDKIT=1</code> on the CLI before invoking <code>docker build</code>.</p>
<p>为了使用 BuildKit 后端，在调用 DOCKER build 之前，你需要在 CLI 上设置一个环境变量的 DOCKER/BuildKit = 1。</p>
<p>To learn about the experimental Dockerfile syntax available to BuildKit-based builds <a href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md" target="_blank" rel="noopener">refer to the documentation in the BuildKit repository</a>.</p>
<p>要了解可用于基于 BuildKit 的构建的实验性 Dockerfile 语法，请参阅 BuildKit 存储库中的文档。</p>
<h2 id="Format-格式"><a href="#Format-格式" class="headerlink" title="Format 格式"></a>Format 格式</h2><p>Here is the format of the <code>Dockerfile</code>:</p>
<p>下面是 Dockerfile 的格式:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Comment</span></span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure>

<p>The instruction is not case-sensitive. However, convention is for them to be UPPERCASE to distinguish them from arguments more easily.</p>
<p>该指令不区分大小写。但是，约定使用大写形式，以便更容易地与参数区分开来。</p>
<p>Docker runs instructions in a <code>Dockerfile</code> in order. A <code>Dockerfile</code> <strong>must begin with a <code>FROM</code> instruction</strong>. This may be after <a href="https://docs.docker.com/engine/reference/builder/#parser-directives" target="_blank" rel="noopener">parser directives</a>, <a href="https://docs.docker.com/engine/reference/builder/#format" target="_blank" rel="noopener">comments</a>, and globally scoped <a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank" rel="noopener">ARGs</a>. The <code>FROM</code> instruction specifies the <a href="https://docs.docker.com/glossary/#parent_image" target="_blank" rel="noopener"><em>Parent Image</em></a> from which you are building. <code>FROM</code> may only be preceded by one or more <code>ARG</code> instructions, which declare arguments that are used in <code>FROM</code> lines in the <code>Dockerfile</code>.</p>
<p>Docker 按顺序在 Dockerfile 中运行指令。Dockerfile 必须以 FROM 指令开头。这可能是在解析器指令、注释和全局范围的 ARGs 之后。FROM 指令指定要从中构建的父映像。FROM 之前只能有一个或多个 ARG 指令，这些指令声明 Dockerfile 中 FROM 行中使用的参数。</p>
<p>Docker treats lines that <em>begin</em> with <code>#</code> as a comment, unless the line is a valid <a href="https://docs.docker.com/engine/reference/builder/#parser-directives" target="_blank" rel="noopener">parser directive</a>. A <code>#</code> marker anywhere else in a line is treated as an argument. This allows statements like:</p>
<p>Docker 将以 # 开头的行视为注释，除非该行是有效的解析器指令。一行中其他任何地方的 # 标记都被视为参数。这允许这样的陈述:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Comment</span></span><br><span class="line">RUN echo 'we are running some # of cool things'</span><br></pre></td></tr></table></figure>

<p>Comment lines are removed before the Dockerfile instructions are executed, which means that the comment in the following example is not handled by the shell executing the <code>echo</code> command, and both examples below are equivalent:</p>
<p>注释行在执行 Dockerfile 指令之前被删除，这意味着执行 echo 命令的 shell 不会处理下面例子中的注释，下面两个例子是等价的:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUN echo hello \</span><br><span class="line"><span class="meta">#</span><span class="bash"> comment</span></span><br><span class="line">world</span><br><span class="line">RUN echo hello \</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<p>Line continuation characters are not supported in comments.</p>
<p>注释中不支持行继续字符。</p>
<blockquote>
<p><strong>Note on whitespace</strong></p>
<p>关于空格的注释</p>
<p>For backward compatibility, leading whitespace before comments (<code>#</code>) and instructions (such as <code>RUN</code>) are ignored, but discouraged. Leading whitespace is not preserved in these cases, and the following examples are therefore equivalent:</p>
<p>对于向下兼容，在注释(#)和指令(如 RUN)之前的空格被忽略，但是不鼓励。在这些情况下不保留前导空格，因此下面的示例是等效的:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is a comment-line</span></span><br><span class="line">RUN echo hello</span><br><span class="line">RUN echo world</span><br><span class="line"><span class="meta">#</span><span class="bash"> this is a comment-line</span></span><br><span class="line">RUN echo hello</span><br><span class="line">RUN echo world</span><br></pre></td></tr></table></figure>

<p>Note however, that whitespace in instruction <em>arguments</em>, such as the commands following <code>RUN</code>, are preserved, so the following example prints <code>hello world</code> with leading whitespace as specified:</p>
<p>但是请注意，指令参数中的空格，例如 RUN 后面的命令，被保留了下来，所以下面的例子打印了 hello world，前面指定了空格:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"\</span></span></span><br><span class="line"><span class="bash">     hello\</span></span><br><span class="line"><span class="bash">     world<span class="string">"</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Parser-directives-解析器指令"><a href="#Parser-directives-解析器指令" class="headerlink" title="Parser directives 解析器指令"></a>Parser directives 解析器指令</h2><p>Parser directives are optional, and affect the way in which subsequent lines in a <code>Dockerfile</code> are handled. Parser directives do not add layers to the build, and will not be shown as a build step. Parser directives are written as a special type of comment in the form <code># directive=value</code>. A single directive may only be used once.</p>
<p>解析器指令是可选的，它影响 Dockerfile 中后续行的处理方式。解析器指令不向构建添加层，也不会显示为构建步骤。解析器指令作为特殊类型的注释以 # directive = value 的形式编写。单个指令只能使用一次。</p>
<p>Once a comment, empty line or builder instruction has been processed, Docker no longer looks for parser directives. Instead it treats anything formatted as a parser directive as a comment and does not attempt to validate if it might be a parser directive. Therefore, all parser directives must be at the very top of a <code>Dockerfile</code>.</p>
<p>处理完注释、空行或生成器指令后，Docker 不再查找解析器指令。相反，它将任何格式化为解析器指令的东西视为注释，如果它可能是解析器指令，则不尝试验证它。因此，所有解析器指令都必须位于 Dockerfile 的顶部。</p>
<p>Parser directives are not case-sensitive. However, convention is for them to be lowercase. Convention is also to include a blank line following any parser directives. Line continuation characters are not supported in parser directives.</p>
<p>解析器指令不区分大小写。然而，惯例是让它们小写。约定还包括在任何解析器指令之后的空行。解析器指令不支持行继续字符。</p>
<p>Due to these rules, the following examples are all invalid:</p>
<p>由于这些规则，下面的例子都是无效的:</p>
<p>Invalid due to line continuation:</p>
<p>由于行继续而无效:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># direc \</span></span><br><span class="line"><span class="attr">tive</span>=value</span><br></pre></td></tr></table></figure>

<p>Invalid due to appearing twice:</p>
<p>因出现两次而无效:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> directive=value1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> directive=value2</span></span><br><span class="line"></span><br><span class="line">FROM ImageName</span><br></pre></td></tr></table></figure>

<p>Treated as a comment due to appearing after a builder instruction:</p>
<p>由于出现在构建器指令之后而作为注释处理:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ImageName</span><br><span class="line"><span class="meta">#</span><span class="bash"> directive=value</span></span><br></pre></td></tr></table></figure>

<p>Treated as a comment due to appearing after a comment which is not a parser directive:</p>
<p>由于出现在非解析器指令的注释之后而作为注释处理:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> About my dockerfile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> directive=value</span></span><br><span class="line">FROM ImageName</span><br></pre></td></tr></table></figure>

<p>The unknown directive is treated as a comment due to not being recognized. In addition, the known directive is treated as a comment due to appearing after a comment which is not a parser directive.</p>
<p>由于未被识别，未知指令被视为注释。此外，已知的指令被视为注释，因为它出现在注释之后，而注释不是解析器指令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> unknowndirective=value</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> knowndirective=value</span></span><br></pre></td></tr></table></figure>

<p>Non line-breaking whitespace is permitted in a parser directive. Hence, the following lines are all treated identically:</p>
<p>在解析器指令中允许不分行的空格。因此，下列行的处理方式相同:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">directive=value</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> directive =value</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	directive= value</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> directive = value</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	  dIrEcTiVe=value</span></span><br></pre></td></tr></table></figure>

<p>The following parser directives are supported:</p>
<p>支持以下解析器指令:</p>
<ul>
<li><code>syntax</code></li>
<li><code>escape</code></li>
</ul>
<h2 id="syntax-语法"><a href="#syntax-语法" class="headerlink" title="syntax 语法"></a>syntax 语法</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># syntax=[remote <span class="keyword">image</span> <span class="keyword">reference</span>]</span><br></pre></td></tr></table></figure>

<p>For example:</p>
<p>例如:</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># syntax=docker/dockerfile</span></span><br><span class="line"><span class="meta"># syntax=docker/dockerfile:1.0</span></span><br><span class="line"><span class="meta"># syntax=docker.io/docker/dockerfile:1</span></span><br><span class="line"><span class="meta"># syntax=docker/dockerfile:1.0.0-experimental</span></span><br><span class="line"><span class="meta"># syntax=example.com/user/repo:tag@sha256:abcdef...</span></span><br></pre></td></tr></table></figure>

<p>This feature is only enabled if the <a href="https://docs.docker.com/engine/reference/builder/#buildkit" target="_blank" rel="noopener">BuildKit</a> backend is used.</p>
<p>只有在使用 BuildKit 后端时才启用这个特性。</p>
<p>The syntax directive defines the location of the Dockerfile builder that is used for building the current Dockerfile. The BuildKit backend allows to seamlessly use external implementations of builders that are distributed as Docker images and execute inside a container sandbox environment.</p>
<p>Syntax 指令定义用于构建当前 Dockerfile 的 Dockerfile 构建器的位置。BuildKit 后端允许无缝地使用构建器的外部实现，这些构建器以 Docker 映像的形式分发，并在容器沙箱环境中执行。</p>
<p>Custom Dockerfile implementation allows you to:</p>
<p>自定义 Dockerfile 实现允许您:</p>
<ul>
<li>Automatically get bugfixes without updating the daemon 无需更新守护进程即可自动修复错误</li>
<li>Make sure all users are using the same implementation to build your Dockerfile 确保所有用户都使用相同的实现来构建 Dockerfile</li>
<li>Use the latest features without updating the daemon 使用最新的特性而不更新守护进程</li>
<li>Try out new experimental or third-party features 尝试新的实验性或第三方功能</li>
</ul>
<h3 id="Official-releases-官方发布"><a href="#Official-releases-官方发布" class="headerlink" title="Official releases 官方发布"></a>Official releases 官方发布</h3><p>Docker distributes official versions of the images that can be used for building Dockerfiles under <code>docker/dockerfile</code> repository on Docker Hub. There are two channels where new images are released: stable and experimental.</p>
<p>Docker 发布了可用于在 Docker Hub 上的 Docker/dockerfile 存储库下构建 Dockerfiles 的图像的官方版本。有两种渠道可以发布新的图像: 稳定的和实验性的。</p>
<p>Stable channel follows semantic versioning. For example:</p>
<p>稳定通道遵循语义版本。例如:</p>
<ul>
<li><code>docker/dockerfile:1.0.0</code> - only allow immutable version - 只允许不可变版本<code>1.0.0</code></li>
<li><code>docker/dockerfile:1.0</code> - allow versions - 允许版本<code>1.0.*</code></li>
<li><code>docker/dockerfile:1</code> - allow versions - 允许版本<code>1.*.*</code></li>
<li><code>docker/dockerfile:latest</code> - latest release on stable channel - 稳定频道最新消息</li>
</ul>
<p>The experimental channel uses incremental versioning with the major and minor component from the stable channel on the time of the release. For example:</p>
<p>实验通道在发布时使用来自稳定通道的主要和次要组件的增量版本控制。例如:</p>
<ul>
<li><code>docker/dockerfile:1.0.1-experimental</code> - only allow immutable version - 只允许不可变版本<code>1.0.1-experimental</code></li>
<li><code>docker/dockerfile:1.0-experimental</code> - latest experimental releases after - 最新的实验性发布<code>1.0</code></li>
<li><code>docker/dockerfile:experimental</code> - latest release on experimental channel - 实验频道最新推出</li>
</ul>
<p>You should choose a channel that best fits your needs. If you only want bugfixes, you should use <code>docker/dockerfile:1.0</code>. If you want to benefit from experimental features, you should use the experimental channel. If you are using the experimental channel, newer releases may not be backwards compatible, so it is recommended to use an immutable full version variant.</p>
<p>你应该选择一个最适合你需要的频道。如果你只想修复错误，你应该使用 docker/dockerfile: 1.0。如果你想从实验特性中获益，你应该使用实验频道。如果您正在使用实验通道，较新的版本可能无法向后兼容，因此建议使用不可变的完整版本变量。</p>
<p>For master builds and nightly feature releases refer to the description in <a href="https://github.com/moby/buildkit/blob/master/README.md" target="_blank" rel="noopener">the source repository</a>.</p>
<p>对于主版本和夜间特性版本，请参考源代码存储库中的描述。</p>
<h2 id="escape-逃跑"><a href="#escape-逃跑" class="headerlink" title="escape 逃跑"></a>escape 逃跑</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># escape=\ (backslash)</span></span><br></pre></td></tr></table></figure>

<p>Or</p>
<p>或者</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># escape=` (backtick)</span></span><br></pre></td></tr></table></figure>

<p>The <code>escape</code> directive sets the character used to escape characters in a <code>Dockerfile</code>. If not specified, the default escape character is <code>\</code>.</p>
<p>Escape 指令设置用于转义 Dockerfile 中的字符的字符。如果未指定，则默认转义字符为。</p>
<p>The escape character is used both to escape characters in a line, and to escape a newline. This allows a <code>Dockerfile</code> instruction to span multiple lines. Note that regardless of whether the <code>escape</code> parser directive is included in a <code>Dockerfile</code>, <em>escaping is not performed in a <code>RUN</code> command, except at the end of a line.</em></p>
<p>转义字符既用于转义行中的字符，也用于转义换行符。这允许 Dockerfile 指令跨越多行。注意，不管转义解析器指令是否包含在 Dockerfile 中，RUN 命令中都不执行转义，除非是在行尾。</p>
<p>Setting the escape character to <code>is especially useful on `Windows`, where `\` is the directory path separator.</code> is consistent with <a href="https://technet.microsoft.com/en-us/library/hh847755.aspx" target="_blank" rel="noopener">Windows PowerShell</a>.</p>
<p>在 Windows 中，将转义字符设置为‘尤其有用，因为在 Windows 中，目录路径分隔符是。与 Windows PowerShell 一致。</p>
<p>Consider the following example which would fail in a non-obvious way on <code>Windows</code>. The second <code>\</code> at the end of the second line would be interpreted as an escape for the newline, instead of a target of the escape from the first <code>\</code>. Similarly, the <code>\</code> at the end of the third line would, assuming it was actually handled as an instruction, cause it be treated as a line continuation. The result of this dockerfile is that second and third lines are considered a single instruction:</p>
<p>考虑下面的示例，它在 Windows 上以一种非显而易见的方式失败。第二行末尾的第二行将被解释为换行符的转义，而不是从第一行转义的目标。类似地，假设第三行的末尾处实际上是作为指令处理的，那么第三行的末尾处将把它作为行继续处理。这个 dockerfile 的结果是第二行和第三行被认为是一条指令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/nanoserver</span><br><span class="line">COPY testfile.txt c:\\</span><br><span class="line">RUN dir c:\</span><br></pre></td></tr></table></figure>

<p>Results in:</p>
<p>结果如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\John&gt; docker build -t cmd .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1/2 : FROM microsoft/nanoserver</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 22738ff49c6d</span></span><br><span class="line">Step 2/2 : COPY testfile.txt c:\RUN dir c:</span><br><span class="line">GetFileAttributesEx c:RUN: The system cannot find the file specified.</span><br><span class="line">PS C:\John&gt;</span><br></pre></td></tr></table></figure>

<p>One solution to the above would be to use <code>/</code> as the target of both the <code>COPY</code> instruction, and <code>dir</code>. However, this syntax is, at best, confusing as it is not natural for paths on <code>Windows</code>, and at worst, error prone as not all commands on <code>Windows</code> support <code>/</code> as the path separator.</p>
<p>解决上述问题的一个办法是使用/作为 COPY 指令和 dir 的目标。但是，这种语法充其量是令人困惑的，因为它对于 Windows 上的路径来说并不自然，而且在最糟糕的情况下，它容易出错，因为 Windows 上的并非所有命令都支持/作为路径分隔符。</p>
<p>By adding the <code>escape</code> parser directive, the following <code>Dockerfile</code> succeeds as expected with the use of natural platform semantics for file paths on <code>Windows</code>:</p>
<p>通过添加 escape 语法分析器指令，下面的 Dockerfile 在 Windows 文件路径中使用自然平台语义成功:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> escape=`</span></span><br><span class="line"></span><br><span class="line">FROM microsoft/nanoserver</span><br><span class="line">COPY testfile.txt c:\</span><br><span class="line">RUN dir c:\</span><br></pre></td></tr></table></figure>

<p>Results in:</p>
<p>结果如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PS C:\John&gt; docker build -t succeeds --no-cache=true .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1/3 : FROM microsoft/nanoserver</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 22738ff49c6d</span></span><br><span class="line">Step 2/3 : COPY testfile.txt c:\</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 96655de338de</span></span><br><span class="line">Removing intermediate container 4db9acbb1682</span><br><span class="line">Step 3/3 : RUN dir c:\</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> a2c157f842f5</span></span><br><span class="line"> Volume in drive C has no label.</span><br><span class="line"> Volume Serial Number is 7E6D-E0F7</span><br><span class="line"></span><br><span class="line"> Directory of c:\</span><br><span class="line"></span><br><span class="line">10/05/2016  05:04 PM             1,894 License.txt</span><br><span class="line">10/05/2016  02:22 PM    &lt;DIR&gt;          Program Files</span><br><span class="line">10/05/2016  02:14 PM    &lt;DIR&gt;          Program Files (x86)</span><br><span class="line">10/28/2016  11:18 AM                62 testfile.txt</span><br><span class="line">10/28/2016  11:20 AM    &lt;DIR&gt;          Users</span><br><span class="line">10/28/2016  11:20 AM    &lt;DIR&gt;          Windows</span><br><span class="line">           2 File(s)          1,956 bytes</span><br><span class="line">           4 Dir(s)  21,259,096,064 bytes free</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 01c7f3bef04f</span></span><br><span class="line">Removing intermediate container a2c157f842f5</span><br><span class="line">Successfully built 01c7f3bef04f</span><br><span class="line">PS C:\John&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Environment-replacement-环境更新"><a href="#Environment-replacement-环境更新" class="headerlink" title="Environment replacement 环境更新"></a>Environment replacement 环境更新</h2><p>Environment variables (declared with <a href="https://docs.docker.com/engine/reference/builder/#env" target="_blank" rel="noopener">the <code>ENV</code> statement</a>) can also be used in certain instructions as variables to be interpreted by the <code>Dockerfile</code>. Escapes are also handled for including variable-like syntax into a statement literally.</p>
<p>环境变量(用 ENV 语句声明)也可以在某些指令中用作 Dockerfile 要解释的变量。还处理转义，以便将类似变量的语法包含到字面语句中。</p>
<p>Environment variables are notated in the <code>Dockerfile</code> either with <code>$variable_name</code> or <code>${variable_name}</code>. They are treated equivalently and the brace syntax is typically used to address issues with variable names with no whitespace, like <code>${foo}_bar</code>.</p>
<p>环境变量在 Dockerfile 中用 $variable _ name 或 ${ variable _ name }标记。它们被等价对待，大括号语法通常用于处理带有没有空格的变量名的问题，比如 ${ foo } _ bar。</p>
<p>The <code>${variable_name}</code> syntax also supports a few of the standard <code>bash</code> modifiers as specified below:</p>
<p>${ variable _ name }语法还支持下面指定的几个标准 bash 修饰符:</p>
<ul>
<li><code>${variable:-word}</code> indicates that if 表明如果<code>variable</code> is set then the result will be that value. If 那么结果就是这个值<code>variable</code> is not set then 还没有定下来<code>word</code> will be the result. 就是结果</li>
<li><code>${variable:+word}</code> indicates that if 表明如果<code>variable</code> is set then 就这么定了<code>word</code> will be the result, otherwise the result is the empty string. 将是结果，否则结果是空字符串</li>
</ul>
<p>In all cases, <code>word</code> can be any string, including additional environment variables.</p>
<p>在所有情况下，word 可以是任何字符串，包括其他环境变量。</p>
<p>Escaping is possible by adding a <code>\</code> before the variable: <code>\$foo</code> or <code>\${foo}</code>, for example, will translate to <code>$foo</code> and <code>${foo}</code> literals respectively.</p>
<p>可以通过在变量之前添加 a 来实现转义: $foo 或 ${ foo } ，例如，将分别转换为 $foo 和 ${ foo }文字。</p>
<p>Example (parsed representation is displayed after the <code>#</code>):</p>
<p>示例(在 # 之后显示已解析的表示) :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ENV FOO=/bar</span><br><span class="line">WORKDIR $&#123;FOO&#125;   # WORKDIR /bar</span><br><span class="line">ADD . $FOO       # ADD . /bar</span><br><span class="line">COPY \$FOO /quux # COPY $FOO /quux</span><br></pre></td></tr></table></figure>

<p>Environment variables are supported by the following list of instructions in the <code>Dockerfile</code>:</p>
<p>下面的 Dockerfile 中的指令列表支持环境变量:</p>
<ul>
<li><code>ADD</code></li>
<li><code>COPY</code></li>
<li><code>ENV</code></li>
<li><code>EXPOSE</code></li>
<li><code>FROM</code></li>
<li><code>LABEL</code></li>
<li><code>STOPSIGNAL</code></li>
<li><code>USER</code></li>
<li><code>VOLUME</code></li>
<li><code>WORKDIR</code></li>
<li><code>ONBUILD</code> (when combined with one of the supported instructions above) (当与上面支持的指令之一结合时)</li>
</ul>
<p>Environment variable substitution will use the same value for each variable throughout the entire instruction. In other words, in this example:</p>
<p>环境变量替换将在整个指令中对每个变量使用相同的值。换句话说，在这个例子中:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV abc=hello</span><br><span class="line">ENV abc=bye def=$abc</span><br><span class="line">ENV ghi=$abc</span><br></pre></td></tr></table></figure>

<p>will result in <code>def</code> having a value of <code>hello</code>, not <code>bye</code>. However, <code>ghi</code> will have a value of <code>bye</code> because it is not part of the same instruction that set <code>abc</code> to <code>bye</code>.</p>
<p>将导致 def 的值是 hello，而不是 bye。然而，ghi 将有一个 bye 的值，因为它不是将 abc 设置为 bye 的同一个指令的一部分。</p>
<h2 id="dockerignore-file-dockerignore-文件"><a href="#dockerignore-file-dockerignore-文件" class="headerlink" title=".dockerignore file . dockerignore 文件"></a>.dockerignore file . dockerignore 文件</h2><p>Before the docker CLI sends the context to the docker daemon, it looks for a file named <code>.dockerignore</code> in the root directory of the context. If this file exists, the CLI modifies the context to exclude files and directories that match patterns in it. This helps to avoid unnecessarily sending large or sensitive files and directories to the daemon and potentially adding them to images using <code>ADD</code> or <code>COPY</code>.</p>
<p>在 docker CLI 将上下文发送给 docker 守护进程之前，它会查找一个名为。在上下文的根目录中忽略 dockerignore。如果此文件存在，CLI 将修改上下文以排除与其中的模式匹配的文件和目录。这有助于避免不必要地向守护进程发送大型或敏感的文件和目录，并可能使用 ADD 或 COPY 将它们添加到映像中。</p>
<p>The CLI interprets the <code>.dockerignore</code> file as a newline-separated list of patterns similar to the file globs of Unix shells. For the purposes of matching, the root of the context is considered to be both the working and the root directory. For example, the patterns <code>/foo/bar</code> and <code>foo/bar</code> both exclude a file or directory named <code>bar</code> in the <code>foo</code> subdirectory of <code>PATH</code> or in the root of the git repository located at <code>URL</code>. Neither excludes anything else.</p>
<p>的解释。Dockerignore 文件作为类似于 Unix shell 文件 globs 的新行分隔的模式列表。为了进行匹配，上下文的根目录被认为是工作目录和根目录。例如，patterns/foo/bar 和 foo/bar 都排除了 PATH 的 foo 子目录中名为 bar 的文件或目录，或者位于 URL 的 git 存储库的根目录中的 bar。这两者都没有排除其他因素。</p>
<p>If a line in <code>.dockerignore</code> file starts with <code>#</code> in column 1, then this line is considered as a comment and is ignored before interpreted by the CLI.</p>
<p>如果有一行。Dockerignore file 以第1列中的 # 开始，然后这一行被视为注释，在 CLI 解释之前被忽略。</p>
<p>Here is an example <code>.dockerignore</code> file:</p>
<p>下面是一个例子. dockerignore 文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># comment</span><br><span class="line">*&#x2F;temp*</span><br><span class="line">*&#x2F;*&#x2F;temp*</span><br><span class="line">temp?</span><br></pre></td></tr></table></figure>

<p>This file causes the following build behavior:</p>
<p>这个文件会导致如下的构建行为:</p>
<table>
<thead>
<tr>
<th align="left">Rule 规则</th>
<th align="left">Behavior 行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code># comment</code></td>
<td align="left">Ignored. 被忽视</td>
</tr>
<tr>
<td align="left"><code>*/temp*</code></td>
<td align="left">Exclude files and directories whose names start with 排除名称以开头的文件和目录<code>temp</code> in any immediate subdirectory of the root. For example, the plain file 在根目录的任何直接子目录中<code>/somedir/temporary.txt</code> is excluded, as is the directory 和目录一样被排除在外<code>/somedir/temp</code>.</td>
</tr>
<tr>
<td align="left"><code>*/*/temp*</code></td>
<td align="left">Exclude files and directories starting with 排除以下开头的文件和目录<code>temp</code> from any subdirectory that is two levels below the root. For example, 任何位于根目录下面两个级别的子目录,<code>/somedir/subdir/temporary.txt</code> is excluded. 被排除在外</td>
</tr>
<tr>
<td align="left"><code>temp?</code></td>
<td align="left">Exclude files and directories in the root directory whose names are a one-character extension of 排除根目录中名称为一个字符扩展名的文件和目录<code>temp</code>. For example, 。例如:<code>/tempa</code> and 及<code>/tempb</code> are excluded. 排除在外</td>
</tr>
</tbody></table>
<p>Matching is done using Go’s <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener">filepath.Match</a> rules. A preprocessing step removes leading and trailing whitespace and eliminates <code>.</code> and <code>..</code> elements using Go’s <a href="http://golang.org/pkg/path/filepath/#Clean" target="_blank" rel="noopener">filepath.Clean</a>. Lines that are blank after preprocessing are ignored.</p>
<p>匹配是使用 Go 的 filepath 完成的。比赛规则。预处理步骤删除前导和尾随空格并消除。及。.元素使用 Go 的 filepath。保持清洁。忽略预处理后为空的行。</p>
<p>Beyond Go’s filepath.Match rules, Docker also supports a special wildcard string <code>**</code> that matches any number of directories (including zero). For example, <code>**/*.go</code> will exclude all files that end with <code>.go</code> that are found in all directories, including the root of the build context.</p>
<p>超越自我的文件路径。根据匹配规则，Docker 还支持一个特殊的通配符字符串 * * ，该字符串可以匹配任意数量的目录(包括零)。例如，* <em>/</em> 。Go 会排除所有以。在所有目录中都可以找到，包括构建上下文的根目录。</p>
<p>Lines starting with <code>!</code> (exclamation mark) can be used to make exceptions to exclusions. The following is an example <code>.dockerignore</code> file that uses this mechanism:</p>
<p>第一行是！(叹号)可用作除外责任的例外情况。下面是一个例子。使用这个机制的 dockerignore 文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*.md</span><br><span class="line">!README.md</span><br></pre></td></tr></table></figure>

<p>All markdown files <em>except</em> <code>README.md</code> are excluded from the context.</p>
<p>除 README.md 以外的所有减价文件都被排除在上下文之外。</p>
<p>The placement of <code>!</code> exception rules influences the behavior: the last line of the <code>.dockerignore</code> that matches a particular file determines whether it is included or excluded. Consider the following example:</p>
<p>的位置！异常规则影响行为:。与特定文件匹配的 dockerignore 确定是否包含该文件。考虑下面的例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.md</span><br><span class="line">!README*.md</span><br><span class="line">README-secret.md</span><br></pre></td></tr></table></figure>

<p>No markdown files are included in the context except README files other than <code>README-secret.md</code>.</p>
<p>除了 README-secret.md 文件以外的 README 文件，上下文中不包含任何降价文件。</p>
<p>Now consider this example:</p>
<p>现在看看这个例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.md</span><br><span class="line">README-secret.md</span><br><span class="line">!README*.md</span><br></pre></td></tr></table></figure>

<p>All of the README files are included. The middle line has no effect because <code>!README*.md</code> matches <code>README-secret.md</code> and comes last.</p>
<p>所有的 README 文件都包含在内，中间那行没有效果，因为 README * . md 匹配 README-secret.md 文件，并且排在最后。</p>
<p>You can even use the <code>.dockerignore</code> file to exclude the <code>Dockerfile</code> and <code>.dockerignore</code> files. These files are still sent to the daemon because it needs them to do its job. But the <code>ADD</code> and <code>COPY</code> instructions do not copy them to the image.</p>
<p>你甚至可以使用。文件来排除 Dockerfile 和。Dockerignore files.这些文件仍然被发送到守护进程，因为它需要这些文件来完成它的工作。但 ADD 和 COPY 指令不会将它们复制到图像中。</p>
<p>Finally, you may want to specify which files to include in the context, rather than which to exclude. To achieve this, specify <code>*</code> as the first pattern, followed by one or more <code>!</code> exception patterns.</p>
<p>最后，您可能希望指定在上下文中包含哪些文件，而不是排除哪些文件。要实现这一点，请将 * 指定为第一个模式，然后是一个或多个模式！异常模式。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>For historical reasons, the pattern <code>.</code> is ignored.</p>
<p>由于历史原因，这个模式被忽略了。</p>
</blockquote>
<h2 id="FROM-来自"><a href="#FROM-来自" class="headerlink" title="FROM 来自:"></a>FROM 来自:</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<p>Or</p>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<p>Or</p>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<p>The <code>FROM</code> instruction initializes a new build stage and sets the <a href="https://docs.docker.com/glossary/#base_image" target="_blank" rel="noopener"><em>Base Image</em></a> for subsequent instructions. As such, a valid <code>Dockerfile</code> must start with a <code>FROM</code> instruction. The image can be any valid image – it is especially easy to start by <strong>pulling an image</strong> from the <a href="https://docs.docker.com/docker-hub/repos/" target="_blank" rel="noopener"><em>Public Repositories</em></a>.</p>
<p>FROM 指令初始化一个新的构建阶段，并为后续指令设置基本映像。因此，有效的 Dockerfile 必须以 FROM 指令开始。该图像可以是任何有效的图像——从公共存储库中提取图像尤其容易。</p>
<ul>
<li><code>ARG</code> is the only instruction that may precede 是唯一的指示，可能先于<code>FROM</code> in the 在<code>Dockerfile</code>. See 。看到<a href="https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact" target="_blank" rel="noopener">Understand how ARG and FROM interact 了解 ARG 和 FROM 是如何相互作用的</a>.</li>
<li><code>FROM</code> can appear multiple times within a single 可以出现在一个单独的<code>Dockerfile</code> to create multiple images or use one build stage as a dependency for another. Simply make a note of the last image ID output by the commit before each new 创建多个映像，或者使用一个构建阶段作为另一个构建阶段的依赖项。只需记录每次新建之前提交的最后一个图像 ID 输出<code>FROM</code> instruction. Each 指示。每项<code>FROM</code> instruction clears any state created by previous instructions. 指令清除由前面的指令创建的任何状态</li>
<li>Optionally a name can be given to a new build stage by adding 可选地，通过添加<code>AS name</code> to the 到<code>FROM</code> instruction. The name can be used in subsequent 该名称可在随后的<code>FROM</code> and 及<code>COPY --from=&lt;name&gt;</code> instructions to refer to the image built in this stage. 指示参考在这个阶段建立的图像</li>
<li>The 这个<code>tag</code> or 或<code>digest</code> values are optional. If you omit either of them, the builder assumes a 值是可选的。如果省略其中任何一个，则构建器假定<code>latest</code> tag by default. The builder returns an error if it cannot find the 标记。如果生成器无法找到<code>tag</code> value. 价值</li>
</ul>
<p>The optional <code>--platform</code> flag can be used to specify the platform of the image in case <code>FROM</code> references a multi-platform image. For example, <code>linux/amd64</code>, <code>linux/arm64</code>, or <code>windows/amd64</code>. By default, the target platform of the build request is used. Global build arguments can be used in the value of this flag, for example <a href="https://docs.docker.com/engine/reference/builder/#automatic-platform-args-in-the-global-scope" target="_blank" rel="noopener">automatic platform ARGs</a> allow you to force a stage to native build platform (<code>--platform=$BUILDPLATFORM</code>), and use it to cross-compile to the target platform inside the stage.</p>
<p>可选的 – platform 标志可用于指定图像的平台，以防 FROM 引用多平台图像。例如，linux/amd64、 linux/arm64或 windows/amd64。默认情况下，使用生成请求的目标平台。可以在这个标志的值中使用全局构建参数，例如，自动平台 ARGs 允许您强制一个阶段到本机构建平台(– platform = $BUILDPLATFORM) ，并使用它在阶段内交叉编译到目标平台。</p>
<h3 id="Understand-how-ARG-and-FROM-interact-了解-ARG-和-FROM-是如何相互作用的"><a href="#Understand-how-ARG-and-FROM-interact-了解-ARG-和-FROM-是如何相互作用的" class="headerlink" title="Understand how ARG and FROM interact 了解 ARG 和 FROM 是如何相互作用的"></a>Understand how ARG and FROM interact 了解 ARG 和 FROM 是如何相互作用的</h3><p><code>FROM</code> instructions support variables that are declared by any <code>ARG</code> instructions that occur before the first <code>FROM</code>.</p>
<p>FROM 指令支持由第一个 FROM 之前的任何 ARG 指令声明的变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ARG  CODE_VERSION=latest</span><br><span class="line">FROM base:$&#123;CODE_VERSION&#125;</span><br><span class="line">CMD  /code/run-app</span><br><span class="line"></span><br><span class="line">FROM extras:$&#123;CODE_VERSION&#125;</span><br><span class="line">CMD  /code/run-extras</span><br></pre></td></tr></table></figure>

<p>An <code>ARG</code> declared before a <code>FROM</code> is outside of a build stage, so it can’t be used in any instruction after a <code>FROM</code>. To use the default value of an <code>ARG</code> declared before the first <code>FROM</code> use an <code>ARG</code> instruction without a value inside of a build stage:</p>
<p>在 FROM 之前声明的 ARG 不在构建阶段之内，因此不能在 FROM 之后的任何指令中使用它。若要使用在第一个 FROM 之前声明的 ARG 的默认值，请在构建阶段中使用没有值的 ARG 指令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG VERSION=latest</span><br><span class="line">FROM busybox:$VERSION</span><br><span class="line">ARG VERSION</span><br><span class="line">RUN echo $VERSION &gt; image_version</span><br></pre></td></tr></table></figure>

<h2 id="RUN-快跑"><a href="#RUN-快跑" class="headerlink" title="RUN 快跑"></a>RUN 快跑</h2><p>RUN has 2 forms:</p>
<p>RUN 有两种形式:</p>
<ul>
<li><code>RUN &lt;command&gt;</code> (<em>shell 贝壳</em> form, the command is run in a shell, which by default is 命令是在 shell 中运行的，默认情况下是<code>/bin/sh -c</code> on Linux or 在 Linux 或<code>cmd /S /C</code> on Windows) 视窗操作系统)</li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (<em>exec 执行官</em> form) 表格)</li>
</ul>
<p>The <code>RUN</code> instruction will execute any commands in a new layer on top of the current image and commit the results. The resulting committed image will be used for the next step in the <code>Dockerfile</code>.</p>
<p>RUN 指令将在当前映像顶部的新层中执行任何命令并提交结果。生成的提交映像将用于 Dockerfile 中的下一步。</p>
<p>Layering <code>RUN</code> instructions and generating commits conforms to the core concepts of Docker where commits are cheap and containers can be created from any point in an image’s history, much like source control.</p>
<p>分层运行指令和生成提交符合 Docker 的核心概念，其中提交很便宜，容器可以从映像历史中的任何一点创建，很像源代码控制。</p>
<p>The <em>exec</em> form makes it possible to avoid shell string munging, and to <code>RUN</code> commands using a base image that does not contain the specified shell executable.</p>
<p>Exec 表单使得可以避免 shell 字符串的转换，并使用不包含指定的 shell 可执行文件的基本映像运行命令。</p>
<p>The default shell for the <em>shell</em> form can be changed using the <code>SHELL</code> command.</p>
<p>可以使用 SHELL 命令更改 SHELL 窗体的默认 SHELL。</p>
<p>In the <em>shell</em> form you can use a <code>\</code> (backslash) to continue a single RUN instruction onto the next line. For example, consider these two lines:</p>
<p>在 shell 表单中，可以使用(反斜杠)将单个 RUN 指令继续到下一行。例如，考虑这两行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN /bin/bash -c 'source $HOME/.bashrc; \</span><br><span class="line">echo $HOME'</span><br></pre></td></tr></table></figure>

<p>Together they are equivalent to this single line:</p>
<p>它们加在一起就相当于这一句话:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'</span><br></pre></td></tr></table></figure>

<p>To use a different shell, other than ‘/bin/sh’, use the <em>exec</em> form passing in the desired shell. For example:</p>
<p>要使用不同的 shell (除了“/bin/sh”) ，可以使用 exec 表单传递所需的 shell。例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN ["/bin/bash", "-c", "echo hello"]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>The <em>exec</em> form is parsed as a JSON array, which means that you must use double-quotes (“) around words not single-quotes (‘).</p>
<p>Exec 表单被解析为 JSON 数组，这意味着必须在单引号(‘)前后使用双引号(“)。</p>
</blockquote>
<p>Unlike the <em>shell</em> form, the <em>exec</em> form does not invoke a command shell. This means that normal shell processing does not happen. For example, <code>RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</code> will not do variable substitution on <code>$HOME</code>. If you want shell processing then either use the <em>shell</em> form or execute a shell directly, for example: <code>RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.</p>
<p>与 shell 窗体不同，exec 窗体不调用命令 shell。这意味着不会发生正常的 shell 处理。例如，RUN [“ echo” ，“ $HOME”]不会对 $HOME 进行变量替换。如果您想要 shell 处理，那么可以使用 shell 表单或者直接执行 shell，例如: RUN [“ sh” ，”-c” ，“ echo $HOME”]。当使用 exec 表单并直接执行一个 shell 时，就像 shell 表单的例子一样，执行环境变量扩展的是 shell，而不是 docker。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>In the <em>JSON</em> form, it is necessary to escape backslashes. This is particularly relevant on Windows where the backslash is the path separator. The following line would otherwise be treated as <em>shell</em> form due to not being valid JSON, and fail in an unexpected way:</p>
<p>在 JSON 格式中，有必要对反斜杠进行转义。这在 Windows 上尤其相关，因为反斜杠是路径分隔符。否则，下面的行将被视为 shell 表单，因为它不是有效的 JSON，并且以意外的方式失败:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN ["c:\windows\system32\tasklist.exe"]</span><br></pre></td></tr></table></figure>

<p>The correct syntax for this example is:</p>
<p>这个例子的正确语法是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN ["c:\\windows\\system32\\tasklist.exe"]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>The cache for <code>RUN</code> instructions isn’t invalidated automatically during the next build. The cache for an instruction like <code>RUN apt-get dist-upgrade -y</code> will be reused during the next build. The cache for <code>RUN</code> instructions can be invalidated by using the <code>--no-cache</code> flag, for example <code>docker build --no-cache</code>.</p>
<p>在下一次生成期间，RUN 指令的缓存不会自动失效。像 RUN apt-get dist-upgrade-y 这样的指令的缓存将在下一次构建期间重用。可以使用 – no-cache 标志使 RUN 指令的缓存失效，例如 docker build – no-cache。</p>
<p>See the <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener"><code>Dockerfile</code> Best Practices guide</a> for more information.</p>
<p>有关更多信息，请参见 Dockerfile 最佳实践指南。</p>
<p>The cache for <code>RUN</code> instructions can be invalidated by <a href="https://docs.docker.com/engine/reference/builder/#add" target="_blank" rel="noopener"><code>ADD</code></a> and <a href="https://docs.docker.com/engine/reference/builder/#copy" target="_blank" rel="noopener"><code>COPY</code></a> instructions.</p>
<p>用于 RUN 指令的缓存可以通过 ADD 和 COPY 指令使其失效。</p>
<h3 id="Known-issues-RUN-已知问题-RUN"><a href="#Known-issues-RUN-已知问题-RUN" class="headerlink" title="Known issues (RUN) 已知问题(RUN)"></a>Known issues (RUN) 已知问题(RUN)</h3><ul>
<li><p><a href="https://github.com/docker/docker/issues/783" target="_blank" rel="noopener">Issue 783</a> is about file permissions problems that can occur when using the AUFS file system. You might notice it during an attempt to <code>rm</code> a file, for example.</p>
<p>问题783是关于在使用 AUFS 文件系统时可能发生的文件权限问题。例如，您可能会在尝试记录文件时注意到它。</p>
<p>For systems that have recent aufs version (i.e., <code>dirperm1</code> mount option can be set), docker will attempt to fix the issue automatically by mounting the layers with <code>dirperm1</code> option. More details on <code>dirperm1</code> option can be found at <a href="https://github.com/sfjro/aufs3-linux/tree/aufs3.18/Documentation/filesystems/aufs" target="_blank" rel="noopener"><code>aufs</code> man page</a></p>
<p>对于最近有 aufs 版本的系统(例如，可以设置 dirperm1 mount 选项) ，docker 将尝试通过使用 dirperm1选项挂载图层来自动修复问题。有关 dirperm1选项的更多详细信息，请参阅 aufs 手册页</p>
<p>If your system doesn’t have support for <code>dirperm1</code>, the issue describes a workaround.</p>
<p>如果您的系统不支持 dirperm1，那么这个问题将描述一个解决方案。</p>
</li>
</ul>
<h2 id="CMD-中国医学博士学位"><a href="#CMD-中国医学博士学位" class="headerlink" title="CMD 中国医学博士学位"></a>CMD 中国医学博士学位</h2><p>The <code>CMD</code> instruction has three forms:</p>
<p>CMD 指令有三种形式:</p>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> (<em>exec 执行官</em> form, this is the preferred form) 表格，这是首选的表格)</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> (as (作为<em>default parameters to ENTRYPOINT ENTRYPOINT 的缺省参数</em>)</li>
<li><code>CMD command param1 param2</code> (<em>shell 贝壳</em> form) 表格)</li>
</ul>
<p>There can only be one <code>CMD</code> instruction in a <code>Dockerfile</code>. If you list more than one <code>CMD</code> then only the last <code>CMD</code> will take effect.</p>
<p>一个 Dockerfile 中只能有一条 CMD 指令。如果您列出了多个 CMD，那么只有最后一个 CMD 才会生效。</p>
<p><strong>The main purpose of a <code>CMD</code> is to provide defaults for an executing container.</strong> These defaults can include an executable, or they can omit the executable, in which case you must specify an <code>ENTRYPOINT</code> instruction as well.</p>
<p>CMD 的主要目的是为正在执行的容器提供缺省值。这些缺省值可以包括一个可执行文件，也可以省略可执行文件，在这种情况下，还必须指定 ENTRYPOINT 指令。</p>
<p>If <code>CMD</code> is used to provide default arguments for the <code>ENTRYPOINT</code> instruction, both the <code>CMD</code> and <code>ENTRYPOINT</code> instructions should be specified with the JSON array format.</p>
<p>如果使用 CMD 为 ENTRYPOINT 指令提供默认参数，则应使用 JSON 数组格式指定 CMD 和 ENTRYPOINT 指令。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>The <em>exec</em> form is parsed as a JSON array, which means that you must use double-quotes (“) around words not single-quotes (‘).</p>
<p>Exec 表单被解析为 JSON 数组，这意味着必须在单引号(‘)前后使用双引号(“)。</p>
</blockquote>
<p>Unlike the <em>shell</em> form, the <em>exec</em> form does not invoke a command shell. This means that normal shell processing does not happen. For example, <code>CMD [ &quot;echo&quot;, &quot;$HOME&quot; ]</code> will not do variable substitution on <code>$HOME</code>. If you want shell processing then either use the <em>shell</em> form or execute a shell directly, for example: <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.</p>
<p>与 shell 窗体不同，exec 窗体不调用命令 shell。这意味着不会发生正常的 shell 处理。例如，CMD [“ echo” ，“ $HOME”]不会对 $HOME 进行变量替换。如果您想要 shell 处理，那么可以使用 shell 表单或者直接执行 shell，例如: CMD [“ sh” ，”-c” ，“ echo $HOME”]。当使用 exec 表单并直接执行一个 shell 时，就像 shell 表单的例子一样，执行环境变量扩展的是 shell，而不是 docker。</p>
<p>When used in the shell or exec formats, the <code>CMD</code> instruction sets the command to be executed when running the image.</p>
<p>在 shell 或 exec 格式中使用时，CMD 指令设置运行映像时要执行的命令。</p>
<p>If you use the <em>shell</em> form of the <code>CMD</code>, then the <code>&lt;command&gt;</code> will execute in <code>/bin/sh -c</code>:</p>
<p>如果您使用 CMD 的 shell 形式，那么 &lt; command &gt; 将在/bin/sh-c 中执行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">CMD echo "This is a test." | wc -</span><br></pre></td></tr></table></figure>

<p>If you want to <strong>run your</strong> <code>&lt;command&gt;</code> <strong>without a shell</strong> then you must express the command as a JSON array and give the full path to the executable. <strong>This array form is the preferred format of <code>CMD</code>.</strong> Any additional parameters must be individually expressed as strings in the array:</p>
<p>如果希望在不使用 shell 的情况下运行 &lt; command &gt; ，那么必须将命令表示为 JSON 数组，并向可执行文件提供完整路径。这种数组形式是 CMD 的首选格式。任何额外的参数都必须在数组中以字符串的形式单独表示:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">CMD ["/usr/bin/wc","--help"]</span><br></pre></td></tr></table></figure>

<p>If you would like your container to run the same executable every time, then you should consider using <code>ENTRYPOINT</code> in combination with <code>CMD</code>. See <a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank" rel="noopener"><em>ENTRYPOINT</em></a>.</p>
<p>如果希望容器每次都运行相同的可执行文件，那么应该考虑结合使用 ENTRYPOINT 和 CMD。参见 ENTRYPOINT。</p>
<p>If the user specifies arguments to <code>docker run</code> then they will override the default specified in <code>CMD</code>.</p>
<p>如果用户指定要 docker 运行的参数，那么它们将覆盖 CMD 中指定的缺省值。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>Do not confuse <code>RUN</code> with <code>CMD</code>. <code>RUN</code> actually runs a command and commits the result; <code>CMD</code> does not execute anything at build time, but specifies the intended command for the image.</p>
<p>不要将 RUN 与 CMD 混淆。RUN 实际上运行一个命令并提交结果; CMD 在构建时不执行任何内容，但是为映像指定预期的命令。</p>
</blockquote>
<h2 id="LABEL-标签"><a href="#LABEL-标签" class="headerlink" title="LABEL 标签"></a>LABEL 标签</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>

<p>The <code>LABEL</code> instruction adds metadata to an image. A <code>LABEL</code> is a key-value pair. To include spaces within a <code>LABEL</code> value, use quotes and backslashes as you would in command-line parsing. A few usage examples:</p>
<p>LABEL 指令向映像添加元数据。LABEL 是键值对。若要在 LABEL 值中包含空格，请像在命令行解析中那样使用引号和反斜杠。一些用法例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LABEL "com.example.vendor"="ACME Incorporated"</span><br><span class="line">LABEL com.example.label-with-value="foo"</span><br><span class="line">LABEL version="1.0"</span><br><span class="line">LABEL description="This text illustrates \</span><br><span class="line">that label-values can span multiple lines."</span><br></pre></td></tr></table></figure>

<p>An image can have more than one label. You can specify multiple labels on a single line. Prior to Docker 1.10, this decreased the size of the final image, but this is no longer the case. You may still choose to specify multiple labels in a single instruction, in one of the following two ways:</p>
<p>一个图像可以有多个标签。可以在一行中指定多个标签。在 Docker 1.10之前，这减少了最终图像的大小，但是现在不是这样了。您仍然可以选择在一条指令中指定多个标签，方法如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LABEL multi.label1="value1" multi.label2="value2" other="value3"</span><br><span class="line">LABEL multi.label1="value1" \</span><br><span class="line">      multi.label2="value2" \</span><br><span class="line">      other="value3"</span><br></pre></td></tr></table></figure>

<p>Labels included in base or parent images (images in the <code>FROM</code> line) are inherited by your image. If a label already exists but with a different value, the most-recently-applied value overrides any previously-set value.</p>
<p>基本图像或父图像中包含的标签(FROM 行中的图像)由您的图像继承。如果标签已经存在但具有不同的值，则最近应用的值将覆盖以前设置的任何值。</p>
<p>To view an image’s labels, use the <code>docker image inspect</code> command. You can use the <code>--format</code> option to show just the labels;</p>
<p>若要查看图像的标签，请使用 docker image inspect 命令。您可以使用 – format 选项仅显示标签;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect --format='' myimage</span><br><span class="line">&#123;</span><br><span class="line">  "com.example.vendor": "ACME Incorporated",</span><br><span class="line">  "com.example.label-with-value": "foo",</span><br><span class="line">  "version": "1.0",</span><br><span class="line">  "description": "This text illustrates that label-values can span multiple lines.",</span><br><span class="line">  "multi.label1": "value1",</span><br><span class="line">  "multi.label2": "value2",</span><br><span class="line">  "other": "value3"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MAINTAINER-deprecated-维护人员-已弃用"><a href="#MAINTAINER-deprecated-维护人员-已弃用" class="headerlink" title="MAINTAINER (deprecated) 维护人员(已弃用)"></a>MAINTAINER (deprecated) 维护人员(已弃用)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>The <code>MAINTAINER</code> instruction sets the <em>Author</em> field of the generated images. The <code>LABEL</code> instruction is a much more flexible version of this and you should use it instead, as it enables setting any metadata you require, and can be viewed easily, for example with <code>docker inspect</code>. To set a label corresponding to the <code>MAINTAINER</code> field you could use:</p>
<p>MAINTAINER 指令设置生成的图像的 Author 字段。LABEL 指令是一个非常灵活的版本，您应该使用它，因为它支持设置您需要的任何元数据，并且可以很容易地查看，例如使用 docker inspect。要设置与 MAINTAINER 字段对应的标签，可以使用:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL maintainer="SvenDowideit@home.org.au"</span><br></pre></td></tr></table></figure>

<p>This will then be visible from <code>docker inspect</code> with the other labels.</p>
<p>这将是可见的从码头检查与其他标签。</p>
<h2 id="EXPOSE-曝光"><a href="#EXPOSE-曝光" class="headerlink" title="EXPOSE 曝光"></a>EXPOSE 曝光</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>

<p>The <code>EXPOSE</code> instruction informs Docker that the container listens on the specified network ports at runtime. You can specify whether the port listens on TCP or UDP, and the default is TCP if the protocol is not specified.</p>
<p>EXPOSE 指令通知 Docker 容器在运行时监听指定的网络端口。您可以指定端口是否侦听 TCP 或 UDP，如果没有指定协议，则默认为 TCP。</p>
<p>The <code>EXPOSE</code> instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published. To actually publish the port when running the container, use the <code>-p</code> flag on <code>docker run</code> to publish and map one or more ports, or the <code>-P</code> flag to publish all exposed ports and map them to high-order ports.</p>
<p>EXPOSE 指令实际上并不发布端口。它的作用是在构建映像的人和运行容器的人之间形成一种文档，关于打算发布哪些端口。要在运行容器时实际发布端口，可以使用 docker run 上的-p 标志发布和映射一个或多个端口，或使用-p 标志发布所有公开的端口并将它们映射到高阶端口。</p>
<p>By default, <code>EXPOSE</code> assumes TCP. You can also specify UDP:</p>
<p>默认情况下，EXPOSE 假设为 TCP。您也可以指定 UDP:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80/udp</span><br></pre></td></tr></table></figure>

<p>To expose on both TCP and UDP, include two lines:</p>
<p>要在 TCP 和 UDP 上公开，包括两行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80/tcp</span><br><span class="line">EXPOSE 80/udp</span><br></pre></td></tr></table></figure>

<p>In this case, if you use <code>-P</code> with <code>docker run</code>, the port will be exposed once for TCP and once for UDP. Remember that <code>-P</code> uses an ephemeral high-ordered host port on the host, so the port will not be the same for TCP and UDP.</p>
<p>在这种情况下，如果对 docker 运行使用 -p，那么端口将对 TCP 公开一次，对 UDP 公开一次。请记住-p 在主机上使用临时的高序主机端口，因此对于 TCP 和 UDP 端口不会相同。</p>
<p>Regardless of the <code>EXPOSE</code> settings, you can override them at runtime by using the <code>-p</code> flag. For example</p>
<p>不管 EXPOSE 设置如何，您都可以在运行时使用 -p 标志覆盖它们</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80/tcp -p 80:80/udp ...</span><br></pre></td></tr></table></figure>

<p>To set up port redirection on the host system, see <a href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports" target="_blank" rel="noopener">using the -P flag</a>. The <code>docker network</code> command supports creating networks for communication among containers without the need to expose or publish specific ports, because the containers connected to the network can communicate with each other over any port. For detailed information, see the <a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="noopener">overview of this feature</a>.</p>
<p>若要在主机系统上设置端口重定向，请参见使用 -p 标志。Docker network 命令支持在容器之间创建通信网络，而不需要公开或发布特定的端口，因为连接到网络的容器可以通过任何端口彼此通信。有关详细信息，请参阅此特性的概述。</p>
<h2 id="ENV-环境病毒"><a href="#ENV-环境病毒" class="headerlink" title="ENV 环境病毒"></a>ENV 环境病毒</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>

<p>The <code>ENV</code> instruction sets the environment variable <code>&lt;key&gt;</code> to the value <code>&lt;value&gt;</code>. This value will be in the environment for all subsequent instructions in the build stage and can be <a href="https://docs.docker.com/engine/reference/builder/#environment-replacement" target="_blank" rel="noopener">replaced inline</a> in many as well. The value will be interpreted for other environment variables, so quote characters will be removed if they are not escaped. Like command line parsing, quotes and backslashes can be used to include spaces within values.</p>
<p>ENV 指令将环境变量的 &lt; key &gt; 设置为 &lt; value &gt; 。这个值将出现在构建阶段的所有后续指令的环境中，并且可以在许多内联中替换。该值将被解释为其他环境变量，因此，如果引号字符没有转义，则将删除它们。与命令行解析一样，可以使用引号和反斜杠在值中包含空格。</p>
<p>Example:</p>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV MY_NAME="John Doe"</span><br><span class="line">ENV MY_DOG=Rex\ The\ Dog</span><br><span class="line">ENV MY_CAT=fluffy</span><br></pre></td></tr></table></figure>

<p>The <code>ENV</code> instruction allows for multiple <code>&lt;key&gt;=&lt;value&gt; ...</code> variables to be set at one time, and the example below will yield the same net results in the final image:</p>
<p>ENV 指令允许同时设置多个 &lt; key &gt; = &lt; value &gt; … 变量，下面的例子将在最终图像中产生相同的净结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV MY_NAME="John Doe" MY_DOG=Rex\ The\ Dog \</span><br><span class="line">    MY_CAT=fluffy</span><br></pre></td></tr></table></figure>

<p>The environment variables set using <code>ENV</code> will persist when a container is run from the resulting image. You can view the values using <code>docker inspect</code>, and change them using <code>docker run --env &lt;key&gt;=&lt;value&gt;</code>.</p>
<p>当从结果映像运行容器时，使用 ENV 设置的环境变量将持久存在。您可以使用 docker inspect 查看这些值，并使用 docker run – env &lt; key &gt; = &lt; value &gt; 更改它们。</p>
<p>Environment variable persistence can cause unexpected side effects. For example, setting <code>ENV DEBIAN_FRONTEND=noninteractive</code> changes the behavior of <code>apt-get</code>, and may confuse users of your image.</p>
<p>环境变量的持续性会导致意想不到的副作用。例如，设置 ENV debian_frontend = 非交互性会改变 apt-get 的行为，并且可能会使图像的用户感到困惑。</p>
<p>If an environment variable is only needed during build, and not in the final image, consider setting a value for a single command instead:</p>
<p>如果在构建过程中只需要一个环境变量命令，而不是在最终的图像中，那么可以考虑为单个命令设置一个值:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN DEBIAN_FRONTEND=noninteractive apt-get update &amp;&amp; apt-get install -y ...</span><br></pre></td></tr></table></figure>

<p>Or using <a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank" rel="noopener"><code>ARG</code></a>, which is not persisted in the final image:</p>
<p>或者使用 ARG，它不会持久化在最终的图片中:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG DEBIAN_FRONTEND=noninteractive</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Alternative syntax</strong></p>
<p>可供选择的语法</p>
<p>The <code>ENV</code> instruction also allows an alternative syntax <code>ENV &lt;key&gt; &lt;value&gt;</code>, omitting the <code>=</code>. For example:</p>
<p>ENV 指令还允许使用另一种语法 ENV &lt; key &gt; &lt; value &gt; ，省略了 = 。例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV MY_VAR my-value</span><br></pre></td></tr></table></figure>

<p>This syntax does not allow for multiple environment-variables to be set in a single <code>ENV</code> instruction, and can be confusing. For example, the following sets a single environment variable (<code>ONE</code>) with value <code>&quot;TWO= THREE=world&quot;</code>:</p>
<p>此语法不允许在单个 ENV 指令中设置多个环境变量，并且可能会造成混淆。例如，下面设置一个值为“ TWO = THREE = world”的单个环境变量(ONE) :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV ONE TWO= THREE=world</span><br></pre></td></tr></table></figure>

<p>The alternative syntax is supported for backward compatibility, but discouraged for the reasons outlined above, and may be removed in a future release.</p>
<p>这种替代语法在向下兼容中得到了支持，但是由于上述原因不鼓励使用，并且可能会在以后的版本中被删除。</p>
</blockquote>
<h2 id="ADD-注意力缺乏症"><a href="#ADD-注意力缺乏症" class="headerlink" title="ADD 注意力缺乏症"></a>ADD 注意力缺乏症</h2><p>ADD has two forms:</p>
<p>ADD 有两种形式:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;",... "&lt;dest&gt;"]</span><br></pre></td></tr></table></figure>

<p>The latter form is required for paths containing whitespace.</p>
<p>后一种形式是包含空白的路径所必需的。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>The <code>--chown</code> feature is only supported on Dockerfiles used to build Linux containers, and will not work on Windows containers. Since user and group ownership concepts do not translate between Linux and Windows, the use of <code>/etc/passwd</code> and <code>/etc/group</code> for translating user and group names to IDs restricts this feature to only be viable for Linux OS-based containers.</p>
<p>这个—- chown 特性只支持构建 Linux 容器的 Dockerfiles，不支持 Windows 容器。由于用户和组的所有权概念不能在 Linux 和 Windows 之间转换，因此使用/etc/passwd 和/etc/group 将用户和组名称转换为 id 限制了这一特性只适用于基于 Linux 的容器。</p>
</blockquote>
<p>The <code>ADD</code> instruction copies new files, directories or remote file URLs from <code>&lt;src&gt;</code> and adds them to the filesystem of the image at the path <code>&lt;dest&gt;</code>.</p>
<p>ADD 指令从 &lt; src &gt; 复制新的文件、目录或远程文件 url，并将它们添加到位于 &lt; dest &gt; 路径的图像文件系统中。</p>
<p>Multiple <code>&lt;src&gt;</code> resources may be specified but if they are files or directories, their paths are interpreted as relative to the source of the context of the build.</p>
<p>可以指定多个 &lt; src &gt; 资源，但是如果它们是文件或目录，那么它们的路径将被解释为相对于构建上下文的源。</p>
<p>Each <code>&lt;src&gt;</code> may contain wildcards and matching will be done using Go’s <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener">filepath.Match</a> rules. For example:</p>
<p>每个 &lt; src &gt; 可能包含通配符，匹配将使用 Go 的 filepath 来完成。匹配规则。例如:</p>
<p>To add all files starting with “hom”:</p>
<p>添加以“ hom”开头的所有文件:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> hom* /mydir/</span></span><br></pre></td></tr></table></figure>

<p>In the example below, <code>?</code> is replaced with any single character, e.g., “home.txt”.</p>
<p>在下面的示例中，将? 替换为任何单个字符，例如“ home.txt”。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure>

<p>The <code>&lt;dest&gt;</code> is an absolute path, or a path relative to <code>WORKDIR</code>, into which the source will be copied inside the destination container.</p>
<p>&lt; dest &gt; 是一个绝对路径，或者相对于 WORKDIR 的路径，源文件将被复制到目标容器中。</p>
<p>The example below uses a relative path, and adds “test.txt” to <code>&lt;WORKDIR&gt;/relativeDir/</code>:</p>
<p>下面的例子使用了一个相对路径，并将“ test.txt”添加到 &lt; workdir &gt;/relativeDir/:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD test.txt relativeDir/</span><br></pre></td></tr></table></figure>

<p>Whereas this example uses an absolute path, and adds “test.txt” to <code>/absoluteDir/</code></p>
<p>而这个示例使用绝对路径，并将“ test.txt”添加到/absoluteDir/</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD test.txt /absoluteDir/</span><br></pre></td></tr></table></figure>

<p>When adding files or directories that contain special characters (such as <code>[</code> and <code>]</code>), you need to escape those paths following the Golang rules to prevent them from being treated as a matching pattern. For example, to add a file named <code>arr[0].txt</code>, use the following;</p>
<p>当添加包含特殊字符(如[和])的文件或目录时，您需要转义遵循 Golang 规则的那些路径，以防止它们被视为匹配的模式。例如，添加名为 arr [0]的文件。Txt 文件，使用以下命令;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD arr[[]0].txt /mydir/</span><br></pre></td></tr></table></figure>

<p>All new files and directories are created with a UID and GID of 0, unless the optional <code>--chown</code> flag specifies a given username, groupname, or UID/GID combination to request specific ownership of the content added. The format of the <code>--chown</code> flag allows for either username and groupname strings or direct integer UID and GID in any combination. Providing a username without groupname or a UID without GID will use the same numeric UID as the GID. If a username or groupname is provided, the container’s root filesystem <code>/etc/passwd</code> and <code>/etc/group</code> files will be used to perform the translation from name to integer UID or GID respectively. The following examples show valid definitions for the <code>--chown</code> flag:</p>
<p>所有新的文件和目录都使用 UID 和 GID 为0创建，除非可选的 – chown 标志指定给定的用户名、组名或 UID/GID 组合来请求所添加内容的特定所有权。– chown 标志的格式允许在任何组合中使用用户名和组名字符串或直接整数 UID 和 GID。提供不带组名或不带 GID 的 UID 的用户名将使用与 GID 相同的数字 UID。如果提供了用户名或组名，则将分别使用容器的根文件系统/etc/passwd 和/etc/group 文件执行从名称到整数 UID 或 GID 的转换。下面的示例显示了 – chown 标志的有效定义:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD --chown=55:mygroup files* /somedir/</span><br><span class="line">ADD --chown=bin files* /somedir/</span><br><span class="line">ADD --chown=1 files* /somedir/</span><br><span class="line">ADD --chown=10:11 files* /somedir/</span><br></pre></td></tr></table></figure>

<p>If the container root filesystem does not contain either <code>/etc/passwd</code> or <code>/etc/group</code> files and either user or group names are used in the <code>--chown</code> flag, the build will fail on the <code>ADD</code> operation. Using numeric IDs requires no lookup and will not depend on container root filesystem content.</p>
<p>如果容器根文件系统不包含/etc/passwd 或/etc/group 文件，并且 – chown 标志中使用了用户名或组名，那么在 ADD 操作中构建将失败。使用数字 id 不需要查找，也不依赖于容器根文件系统内容。</p>
<p>In the case where <code>&lt;src&gt;</code> is a remote file URL, the destination will have permissions of 600. If the remote file being retrieved has an HTTP <code>Last-Modified</code> header, the timestamp from that header will be used to set the <code>mtime</code> on the destination file. However, like any other file processed during an <code>ADD</code>, <code>mtime</code> will not be included in the determination of whether or not the file has changed and the cache should be updated.</p>
<p>如果 &lt; src &gt; 是远程文件 URL，目标文件的权限为600。如果检索的远程文件具有 HTTP Last-Modified 头，则将使用该头的时间戳来设置目标文件的时间。但是，与 ADD 期间处理的任何其他文件一样，在确定文件是否已更改以及缓存是否应该更新时，不会包括 mtime。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>If you build by passing a <code>Dockerfile</code> through STDIN (<code>docker build - &lt; somefile</code>), there is no build context, so the <code>Dockerfile</code> can only contain a URL based <code>ADD</code> instruction. You can also pass a compressed archive through STDIN: (<code>docker build - &lt; archive.tar.gz</code>), the <code>Dockerfile</code> at the root of the archive and the rest of the archive will be used as the context of the build.</p>
<p>如果您通过 STDIN (docker build-&lt; somefile)传递 Dockerfile 来构建，那么就没有构建上下文，因此 Dockerfile 只能包含基于 URL 的 ADD 指令。您还可以通过 STDIN 传递压缩的归档文件: (docker build-&lt; archive.tar.gz) ，归档文件的根目录下的 Dockerfile 和归档文件的其余部分将用作构建的上下文。</p>
</blockquote>
<p>If your URL files are protected using authentication, you need to use <code>RUN wget</code>, <code>RUN curl</code> or use another tool from within the container as the <code>ADD</code> instruction does not support authentication.</p>
<p>如果您的 URL 文件使用身份验证来保护，那么您需要使用 RUN wget、 RUN curl 或者使用容器内的其他工具，因为 ADD 指令不支持身份验证。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>The first encountered <code>ADD</code> instruction will invalidate the cache for all following instructions from the Dockerfile if the contents of <code>&lt;src&gt;</code> have changed. This includes invalidating the cache for <code>RUN</code> instructions. See the <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" target="_blank" rel="noopener"><code>Dockerfile</code> Best Practices guide – Leverage build cache</a> for more information.</p>
<p>如果 &lt; src &gt; 的内容发生了更改，第一条遇到的 ADD 指令将使所有来自 Dockerfile 的指令的缓存失效。这包括使 RUN 指令的缓存失效。有关更多信息，请参见 Dockerfile Best Practices guide-Leverage build cache。</p>
</blockquote>
<p><code>ADD</code> obeys the following rules:</p>
<p>ADD 遵守以下规则:</p>
<ul>
<li><p>The <code>&lt;src&gt;</code> path must be inside the <em>context</em> of the build; you cannot <code>ADD ../something /something</code>, because the first step of a <code>docker build</code> is to send the context directory (and subdirectories) to the docker daemon.</p>
<p>路径必须位于构建的上下文中，不能添加。.因为 docker 构建的第一步是将上下文目录(和子目录)发送给 docker 守护进程。</p>
</li>
<li><p>If <code>&lt;src&gt;</code> is a URL and <code>&lt;dest&gt;</code> does not end with a trailing slash, then a file is downloaded from the URL and copied to <code>&lt;dest&gt;</code>.</p>
<p>如果 &lt; src &gt; 是一个 URL，而 &lt; dest &gt; 没有以斜杠结尾，那么文件将从 URL 下载并复制到 &lt; dest &gt; 。</p>
</li>
<li><p>If <code>&lt;src&gt;</code> is a URL and <code>&lt;dest&gt;</code> does end with a trailing slash, then the filename is inferred from the URL and the file is downloaded to <code>&lt;dest&gt;/&lt;filename&gt;</code>. For instance, <code>ADD http://example.com/foobar /</code> would create the file <code>/foobar</code>. The URL must have a nontrivial path so that an appropriate filename can be discovered in this case (<code>http://example.com</code> will not work).</p>
<p>如果 &lt; src &gt; 是一个 URL，而 &lt; dest &gt; 确实以一个尾部斜杠结尾，那么文件名就会从 URL 中推断出来，文件就会被下载到 &lt; dest &gt;/&lt; filename &gt; 中。例如，ADD <a href="http://example.com/foobar" target="_blank" rel="noopener">http://example.com/foobar</a> /将创建文件/foobar。URL 必须有一个重要的路径，以便在这种情况下可以发现一个合适的文件名( <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 文件不起作用)。</p>
</li>
<li><p>If <code>&lt;src&gt;</code> is a directory, the entire contents of the directory are copied, including filesystem metadata.</p>
<p>如果 &lt; src &gt; 是一个目录，则复制该目录的全部内容，包括文件系统元数据。</p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>The directory itself is not copied, just its contents.</p>
<p>不复制目录本身，只复制其内容。</p>
</blockquote>
<ul>
<li><p>If <code>&lt;src&gt;</code> is a <em>local</em> tar archive in a recognized compression format (identity, gzip, bzip2 or xz) then it is unpacked as a directory. Resources from <em>remote</em> URLs are <strong>not</strong> decompressed. When a directory is copied or unpacked, it has the same behavior as <code>tar -x</code>, the result is the union of:</p>
<p>如果 &lt; src &gt; 是一个可识别的压缩格式(identity、 gzip、 bzip2或 xz)的本地 tar 归档文件，那么它将被解压缩为一个目录。来自远程 url 的资源不会解压缩。当一个目录被复制或解压缩时，它的行为与 tar-x 相同，结果是:</p>
<ol>
<li>Whatever existed at the destination path and 无论在目的地的路径上存在什么</li>
<li>The contents of the source tree, with conflicts resolved in favor of “2.” on a file-by-file basis. 源树的内容，在逐个文件的基础上以有利于“2. ”的方式解决冲突</li>
</ol>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>Whether a file is identified as a recognized compression format or not is done solely based on the contents of the file, not the name of the file. For example, if an empty file happens to end with <code>.tar.gz</code> this will not be recognized as a compressed file and <strong>will not</strong> generate any kind of decompression error message, rather the file will simply be copied to the destination.</p>
<p>文件是否被标识为可识别的压缩格式完全取决于文件的内容，而不是文件的名称。例如，如果一个空文件碰巧以。Gz 这不会被识别为压缩文件，也不会生成任何类型的解压缩错误消息，而只是将文件复制到目的地。</p>
</blockquote>
</li>
<li><p>If <code>&lt;src&gt;</code> is any other kind of file, it is copied individually along with its metadata. In this case, if <code>&lt;dest&gt;</code> ends with a trailing slash <code>/</code>, it will be considered a directory and the contents of <code>&lt;src&gt;</code> will be written at <code>&lt;dest&gt;/base(&lt;src&gt;)</code>.</p>
<p>如果 &lt; src &gt; 是任何其他类型的文件，那么它将与其元数据一起被单独复制。在这种情况下，如果 &lt; dest &gt; 以斜杠/结尾，它将被视为一个目录，&lt; src &gt; 的内容将被写在 &lt; dest &gt;/base (&lt; src &gt;)。</p>
</li>
<li><p>If multiple <code>&lt;src&gt;</code> resources are specified, either directly or due to the use of a wildcard, then <code>&lt;dest&gt;</code> must be a directory, and it must end with a slash <code>/</code>.</p>
<p>如果直接或由于使用通配符而指定了多个 &lt; src &gt; 资源，那么 &lt; dest &gt; 必须是一个目录，并且必须以斜杠/结束。</p>
</li>
<li><p>If <code>&lt;dest&gt;</code> does not end with a trailing slash, it will be considered a regular file and the contents of <code>&lt;src&gt;</code> will be written at <code>&lt;dest&gt;</code>.</p>
<p>如果 &lt; dest &gt; 没有以斜杠结尾，那么它将被视为一个常规文件，&lt; src &gt; 的内容将在 &lt; dest &gt; 中写入。</p>
</li>
<li><p>If <code>&lt;dest&gt;</code> doesn’t exist, it is created along with all missing directories in its path.</p>
<p>如果 &lt; dest &gt; 不存在，则创建该目录并在其路径中创建所有缺少的目录。</p>
</li>
</ul>
<h2 id="COPY-收到"><a href="#COPY-收到" class="headerlink" title="COPY 收到"></a>COPY 收到</h2><p>COPY has two forms:</p>
<p>复制有两种形式:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;",... "&lt;dest&gt;"]</span><br></pre></td></tr></table></figure>

<p>This latter form is required for paths containing whitespace</p>
<p>后一种形式是包含空白的路径所必需的</p>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>The <code>--chown</code> feature is only supported on Dockerfiles used to build Linux containers, and will not work on Windows containers. Since user and group ownership concepts do not translate between Linux and Windows, the use of <code>/etc/passwd</code> and <code>/etc/group</code> for translating user and group names to IDs restricts this feature to only be viable for Linux OS-based containers.</p>
<p>这个—- chown 特性只支持构建 Linux 容器的 Dockerfiles，不支持 Windows 容器。由于用户和组的所有权概念不能在 Linux 和 Windows 之间转换，因此使用/etc/passwd 和/etc/group 将用户和组名称转换为 id 限制了这一特性只适用于基于 Linux 的容器。</p>
</blockquote>
<p>The <code>COPY</code> instruction copies new files or directories from <code>&lt;src&gt;</code> and adds them to the filesystem of the container at the path <code>&lt;dest&gt;</code>.</p>
<p>COPY 指令从 &lt; src &gt; 复制新的文件或目录，并将它们添加到位于路径 &lt; dest &gt; 的容器的文件系统中。</p>
<p>Multiple <code>&lt;src&gt;</code> resources may be specified but the paths of files and directories will be interpreted as relative to the source of the context of the build.</p>
<p>可以指定多个 &lt; src &gt; 资源，但是文件和目录的路径将被解释为相对于构建上下文的源。</p>
<p>Each <code>&lt;src&gt;</code> may contain wildcards and matching will be done using Go’s <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener">filepath.Match</a> rules. For example:</p>
<p>每个 &lt; src &gt; 可能包含通配符，匹配将使用 Go 的 filepath 来完成。匹配规则。例如:</p>
<p>To add all files starting with “hom”:</p>
<p>添加以“ hom”开头的所有文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br></pre></td></tr></table></figure>

<p>In the example below, <code>?</code> is replaced with any single character, e.g., “home.txt”.</p>
<p>在下面的示例中，将? 替换为任何单个字符，例如“ home.txt”。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>

<p>The <code>&lt;dest&gt;</code> is an absolute path, or a path relative to <code>WORKDIR</code>, into which the source will be copied inside the destination container.</p>
<p>&lt; dest &gt; 是一个绝对路径，或者相对于 WORKDIR 的路径，源文件将被复制到目标容器中。</p>
<p>The example below uses a relative path, and adds “test.txt” to <code>&lt;WORKDIR&gt;/relativeDir/</code>:</p>
<p>下面的例子使用了一个相对路径，并将“ test.txt”添加到 &lt; workdir &gt;/relativeDir/:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY test.txt relativeDir/</span><br></pre></td></tr></table></figure>

<p>Whereas this example uses an absolute path, and adds “test.txt” to <code>/absoluteDir/</code></p>
<p>而这个示例使用绝对路径，并将“ test.txt”添加到/absoluteDir/</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY test.txt /absoluteDir/</span><br></pre></td></tr></table></figure>

<p>When copying files or directories that contain special characters (such as <code>[</code> and <code>]</code>), you need to escape those paths following the Golang rules to prevent them from being treated as a matching pattern. For example, to copy a file named <code>arr[0].txt</code>, use the following;</p>
<p>当复制包含特殊字符(如[和])的文件或目录时，您需要转义遵循 Golang 规则的那些路径，以防止它们被视为匹配的模式。例如，复制名为 arr [0]的文件。Txt 文件，使用以下命令;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY arr[[]0].txt /mydir/</span><br></pre></td></tr></table></figure>

<p>All new files and directories are created with a UID and GID of 0, unless the optional <code>--chown</code> flag specifies a given username, groupname, or UID/GID combination to request specific ownership of the copied content. The format of the <code>--chown</code> flag allows for either username and groupname strings or direct integer UID and GID in any combination. Providing a username without groupname or a UID without GID will use the same numeric UID as the GID. If a username or groupname is provided, the container’s root filesystem <code>/etc/passwd</code> and <code>/etc/group</code> files will be used to perform the translation from name to integer UID or GID respectively. The following examples show valid definitions for the <code>--chown</code> flag:</p>
<p>所有新的文件和目录都使用 UID 和 GID 为0创建，除非可选的 – chown 标志指定给定的用户名、组名或 UID/GID 组合来请求复制内容的特定所有权。– chown 标志的格式允许在任何组合中使用用户名和组名字符串或直接整数 UID 和 GID。提供不带组名或不带 GID 的 UID 的用户名将使用与 GID 相同的数字 UID。如果提供了用户名或组名，则将分别使用容器的根文件系统/etc/passwd 和/etc/group 文件执行从名称到整数 UID 或 GID 的转换。下面的示例显示了 – chown 标志的有效定义:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COPY --chown=55:mygroup files* /somedir/</span><br><span class="line">COPY --chown=bin files* /somedir/</span><br><span class="line">COPY --chown=1 files* /somedir/</span><br><span class="line">COPY --chown=10:11 files* /somedir/</span><br></pre></td></tr></table></figure>

<p>If the container root filesystem does not contain either <code>/etc/passwd</code> or <code>/etc/group</code> files and either user or group names are used in the <code>--chown</code> flag, the build will fail on the <code>COPY</code> operation. Using numeric IDs requires no lookup and does not depend on container root filesystem content.</p>
<p>如果容器根文件系统不包含/etc/passwd 或/etc/group 文件，并且 – chown 标志中使用了用户名或组名，则在 COPY 操作上构建将失败。使用数字 id 不需要查找，也不依赖于容器根文件系统内容。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>If you build using STDIN (<code>docker build - &lt; somefile</code>), there is no build context, so <code>COPY</code> can’t be used.</p>
<p>如果使用 STDIN (docker build-&lt; somefile)进行构建，则不存在构建上下文，因此不能使用 COPY。</p>
</blockquote>
<p>Optionally <code>COPY</code> accepts a flag <code>--from=&lt;name&gt;</code> that can be used to set the source location to a previous build stage (created with <code>FROM .. AS &lt;name&gt;</code>) that will be used instead of a build context sent by the user. In case a build stage with a specified name can’t be found an image with the same name is attempted to be used instead.</p>
<p>(可选) COPY 接受一个标志 – FROM = &lt; name &gt; ，该标志可用于将源位置设置为前一个构建阶段(使用 FROM 创建)。.AS &lt; name &gt;)代替用户发送的构建上下文。如果找不到具有指定名称的构建阶段，则尝试使用具有相同名称的图像。</p>
<p><code>COPY</code> obeys the following rules:</p>
<p>复制遵守以下规则:</p>
<ul>
<li><p>The <code>&lt;src&gt;</code> path must be inside the <em>context</em> of the build; you cannot <code>COPY ../something /something</code>, because the first step of a <code>docker build</code> is to send the context directory (and subdirectories) to the docker daemon.</p>
<p>路径必须位于构建的上下文中，不能复制。.因为 docker 构建的第一步是将上下文目录(和子目录)发送给 docker 守护进程。</p>
</li>
<li><p>If <code>&lt;src&gt;</code> is a directory, the entire contents of the directory are copied, including filesystem metadata.</p>
<p>如果 &lt; src &gt; 是一个目录，则复制该目录的全部内容，包括文件系统元数据。</p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>The directory itself is not copied, just its contents.</p>
<p>不复制目录本身，只复制其内容。</p>
</blockquote>
<ul>
<li><p>If <code>&lt;src&gt;</code> is any other kind of file, it is copied individually along with its metadata. In this case, if <code>&lt;dest&gt;</code> ends with a trailing slash <code>/</code>, it will be considered a directory and the contents of <code>&lt;src&gt;</code> will be written at <code>&lt;dest&gt;/base(&lt;src&gt;)</code>.</p>
<p>如果 &lt; src &gt; 是任何其他类型的文件，那么它将与其元数据一起被单独复制。在这种情况下，如果 &lt; dest &gt; 以斜杠/结尾，它将被视为一个目录，&lt; src &gt; 的内容将被写在 &lt; dest &gt;/base (&lt; src &gt;)。</p>
</li>
<li><p>If multiple <code>&lt;src&gt;</code> resources are specified, either directly or due to the use of a wildcard, then <code>&lt;dest&gt;</code> must be a directory, and it must end with a slash <code>/</code>.</p>
<p>如果直接或由于使用通配符而指定了多个 &lt; src &gt; 资源，那么 &lt; dest &gt; 必须是一个目录，并且必须以斜杠/结束。</p>
</li>
<li><p>If <code>&lt;dest&gt;</code> does not end with a trailing slash, it will be considered a regular file and the contents of <code>&lt;src&gt;</code> will be written at <code>&lt;dest&gt;</code>.</p>
<p>如果 &lt; dest &gt; 没有以斜杠结尾，那么它将被视为一个常规文件，&lt; src &gt; 的内容将在 &lt; dest &gt; 中写入。</p>
</li>
<li><p>If <code>&lt;dest&gt;</code> doesn’t exist, it is created along with all missing directories in its path.</p>
<p>如果 &lt; dest &gt; 不存在，则创建该目录并在其路径中创建所有缺少的目录。</p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>The first encountered <code>COPY</code> instruction will invalidate the cache for all following instructions from the Dockerfile if the contents of <code>&lt;src&gt;</code> have changed. This includes invalidating the cache for <code>RUN</code> instructions. See the <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" target="_blank" rel="noopener"><code>Dockerfile</code> Best Practices guide – Leverage build cache</a> for more information.</p>
<p>如果 &lt; src &gt; 的内容发生了更改，第一条 COPY 指令将使所有来自 Dockerfile 的指令的缓存失效。这包括使 RUN 指令的缓存失效。有关更多信息，请参见 Dockerfile Best Practices guide-Leverage build cache。</p>
</blockquote>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>ENTRYPOINT has two forms:</p>
<p>ENTRYPOINT 有两种形式:</p>
<p>The <em>exec</em> form, which is the preferred form:</p>
<p>执行形式，这是首选的形式:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT ["executable", "param1", "param2"]</span><br></pre></td></tr></table></figure>

<p>The <em>shell</em> form:</p>
<p>外壳形式:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT command param1 param2</span><br></pre></td></tr></table></figure>

<p>An <code>ENTRYPOINT</code> allows you to configure a container that will run as an executable.</p>
<p>ENTRYPOINT 允许您配置将作为可执行文件运行的容器。</p>
<p>For example, the following starts nginx with its default content, listening on port 80:</p>
<p>例如，以下代码以 nginx 的默认内容开始，监听端口80:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -i -t --rm -p 80:80 nginx</span></span><br></pre></td></tr></table></figure>

<p>Command line arguments to <code>docker run &lt;image&gt;</code> will be appended after all elements in an <em>exec</em> form <code>ENTRYPOINT</code>, and will override all elements specified using <code>CMD</code>. This allows arguments to be passed to the entry point, i.e., <code>docker run &lt;image&gt; -d</code> will pass the <code>-d</code> argument to the entry point. You can override the <code>ENTRYPOINT</code> instruction using the <code>docker run --entrypoint</code> flag.</p>
<p>Docker run &lt; image &gt; 的命令行参数将附加在 exec 表单 ENTRYPOINT 中的所有元素之后，并将覆盖使用 CMD 指定的所有元素。这允许将参数传递到入口点，也就是说，docker 运行 &lt; image &gt;-d 会将 -d 参数传递到入口点。您可以使用 docker run – ENTRYPOINT 标志覆盖 ENTRYPOINT 指令。</p>
<p>The <em>shell</em> form prevents any <code>CMD</code> or <code>run</code> command line arguments from being used, but has the disadvantage that your <code>ENTRYPOINT</code> will be started as a subcommand of <code>/bin/sh -c</code>, which does not pass signals. This means that the executable will not be the container’s <code>PID 1</code> - and will <em>not</em> receive Unix signals - so your executable will not receive a <code>SIGTERM</code> from <code>docker stop &lt;container&gt;</code>.</p>
<p>Shell 表单防止使用任何 CMD 或运行命令行参数，但缺点是 ENTRYPOINT 将作为/bin/sh-c 的子命令启动，它不传递信号。这意味着可执行文件不会是容器的 PID 1-也不会接收 Unix 信号-所以你的可执行文件不会接收来自 docker stop &lt; container &gt; 的 SIGTERM。</p>
<p>Only the last <code>ENTRYPOINT</code> instruction in the <code>Dockerfile</code> will have an effect.</p>
<p>只有 Dockerfile 中的最后一条 ENTRYPOINT 指令才会生效。</p>
<h3 id="Exec-form-ENTRYPOINT-example-Exec-形式的-ENTRYPOINT-示例"><a href="#Exec-form-ENTRYPOINT-example-Exec-形式的-ENTRYPOINT-示例" class="headerlink" title="Exec form ENTRYPOINT example Exec 形式的 ENTRYPOINT 示例"></a>Exec form ENTRYPOINT example Exec 形式的 ENTRYPOINT 示例</h3><p>You can use the <em>exec</em> form of <code>ENTRYPOINT</code> to set fairly stable default commands and arguments and then use either form of <code>CMD</code> to set additional defaults that are more likely to be changed.</p>
<p>您可以使用 ENTRYPOINT 的 exec 形式来设置相当稳定的默认命令和参数，然后使用任何一种 CMD 形式来设置更可能更改的其他默认值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT ["top", "-b"]</span><br><span class="line">CMD ["-c"]</span><br></pre></td></tr></table></figure>

<p>When you run the container, you can see that <code>top</code> is the only process:</p>
<p>当你运行容器时，你可以看到 top 是唯一的进程:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm --name <span class="built_in">test</span>  top -H</span></span><br><span class="line"></span><br><span class="line">top - 08:25:00 up  7:27,  0 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Threads:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem:   2056668 total,  1616832 used,   439836 free,    99352 buffers</span><br><span class="line">KiB Swap:  1441840 total,        0 used,  1441840 free.  1324440 cached Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    1 root      20   0   19744   2336   2080 R  0.0  0.1   0:00.04 top</span><br></pre></td></tr></table></figure>

<p>To examine the result further, you can use <code>docker exec</code>:</p>
<p>要进一步检查结果，可以使用 docker exec:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it <span class="built_in">test</span> ps aux</span></span><br><span class="line"></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  2.6  0.1  19752  2352 ?        Ss+  08:24   0:00 top -b -H</span><br><span class="line">root         7  0.0  0.1  15572  2164 ?        R+   08:25   0:00 ps aux</span><br></pre></td></tr></table></figure>

<p>And you can gracefully request <code>top</code> to shut down using <code>docker stop test</code>.</p>
<p>您可以使用 docker stop 测试优雅地请求 top 关闭。</p>
<p>The following <code>Dockerfile</code> shows using the <code>ENTRYPOINT</code> to run Apache in the foreground (i.e., as <code>PID 1</code>):</p>
<p>下面的 Dockerfile 显示使用 ENTRYPOINT 在前台运行 Apache (即 PID 1) :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stable</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2</span><br><span class="line">EXPOSE 80 443</span><br><span class="line">VOLUME ["/var/www", "/var/log/apache2", "/etc/apache2"]</span><br><span class="line">ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]</span><br></pre></td></tr></table></figure>

<p>If you need to write a starter script for a single executable, you can ensure that the final executable receives the Unix signals by using <code>exec</code> and <code>gosu</code> commands:</p>
<p>如果您需要为单个可执行文件编写一个 starter 脚本，您可以使用 exec 和 gosu 命令确保最终的可执行文件接收 Unix 信号:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">if [ "$1" = 'postgres' ]; then</span><br><span class="line">    chown -R postgres "$PGDATA"</span><br><span class="line"></span><br><span class="line">    if [ -z "$(ls -A "$PGDATA")" ]; then</span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    exec gosu postgres "$@"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec "$@"</span><br></pre></td></tr></table></figure>

<p>Lastly, if you need to do some extra cleanup (or communicate with other containers) on shutdown, or are co-ordinating more than one executable, you may need to ensure that the <code>ENTRYPOINT</code> script receives the Unix signals, passes them on, and then does some more work:</p>
<p>最后，如果你需要在关闭时做一些额外的清理(或者与其他容器通信) ，或者协调多个可执行文件，你可能需要确保 ENTRYPOINT 脚本接收 Unix 信号，传递它们，然后做一些更多的工作:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note: I<span class="string">'ve written this using sh so it works in the busybox container too</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> USE the <span class="built_in">trap</span> <span class="keyword">if</span> you need to also <span class="keyword">do</span> manual cleanup after the service is stopped,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     or need to start multiple services <span class="keyword">in</span> the one container</span></span><br><span class="line">trap "echo TRAPed signal" HUP INT QUIT TERM</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> start service <span class="keyword">in</span> background here</span></span><br><span class="line">/usr/sbin/apachectl start</span><br><span class="line"></span><br><span class="line">echo "[hit enter key to exit] or run 'docker stop &lt;container&gt;'"</span><br><span class="line">read</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> stop service and clean up here</span></span><br><span class="line">echo "stopping apache"</span><br><span class="line">/usr/sbin/apachectl stop</span><br><span class="line"></span><br><span class="line">echo "exited $0"</span><br></pre></td></tr></table></figure>

<p>If you run this image with <code>docker run -it --rm -p 80:80 --name test apache</code>, you can then examine the container’s processes with <code>docker exec</code>, or <code>docker top</code>, and then ask the script to stop Apache:</p>
<p>如果您使用 docker run-it-rm-p 80:80-name test Apache 运行这个映像，那么您可以使用 docker exec 或 docker top 检查容器的进程，然后请求脚本停止 Apache:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it <span class="built_in">test</span> ps aux</span></span><br><span class="line"></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.1  0.0   4448   692 ?        Ss+  00:42   0:00 /bin/sh /run.sh 123 cmd cmd2</span><br><span class="line">root        19  0.0  0.2  71304  4440 ?        Ss   00:42   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data    20  0.2  0.2 360468  6004 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data    21  0.2  0.2 360468  6000 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">root        81  0.0  0.1  15572  2140 ?        R+   00:44   0:00 ps aux</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker top <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line">PID                 USER                COMMAND</span><br><span class="line">10035               root                &#123;run.sh&#125; /bin/sh /run.sh 123 cmd cmd2</span><br><span class="line">10054               root                /usr/sbin/apache2 -k start</span><br><span class="line">10055               33                  /usr/sbin/apache2 -k start</span><br><span class="line">10056               33                  /usr/sbin/apache2 -k start</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> /usr/bin/time docker stop <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line">test</span><br><span class="line">real	0m 0.27s</span><br><span class="line">user	0m 0.03s</span><br><span class="line">sys	0m 0.03s</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>You can override the <code>ENTRYPOINT</code> setting using <code>--entrypoint</code>, but this can only set the binary to <em>exec</em> (no <code>sh -c</code> will be used).</p>
<p>您可以使用 – ENTRYPOINT 重写 ENTRYPOINT 设置，但这只能将二进制文件设置为 exec (不使用 sh-c)。</p>
</blockquote>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>The <em>exec</em> form is parsed as a JSON array, which means that you must use double-quotes (“) around words not single-quotes (‘).</p>
<p>Exec 表单被解析为 JSON 数组，这意味着必须在单引号(‘)前后使用双引号(“)。</p>
</blockquote>
<p>Unlike the <em>shell</em> form, the <em>exec</em> form does not invoke a command shell. This means that normal shell processing does not happen. For example, <code>ENTRYPOINT [ &quot;echo&quot;, &quot;$HOME&quot; ]</code> will not do variable substitution on <code>$HOME</code>. If you want shell processing then either use the <em>shell</em> form or execute a shell directly, for example: <code>ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.</p>
<p>与 shell 窗体不同，exec 窗体不调用命令 shell。这意味着不会发生正常的 shell 处理。例如，ENTRYPOINT [“ echo” ，“ $HOME”]不会对 $HOME 进行变量替换。如果希望进行 shell 处理，那么可以使用 shell 表单或直接执行 shell，例如: ENTRYPOINT [“ sh” ，”-c” ，“ echo $HOME”]。当使用 exec 表单并直接执行一个 shell 时，就像 shell 表单的例子一样，执行环境变量扩展的是 shell，而不是 docker。</p>
<h3 id="Shell-form-ENTRYPOINT-example-Shell-表单-ENTRYPOINT-示例"><a href="#Shell-form-ENTRYPOINT-example-Shell-表单-ENTRYPOINT-示例" class="headerlink" title="Shell form ENTRYPOINT example Shell 表单 ENTRYPOINT 示例"></a>Shell form ENTRYPOINT example Shell 表单 ENTRYPOINT 示例</h3><p>You can specify a plain string for the <code>ENTRYPOINT</code> and it will execute in <code>/bin/sh -c</code>. This form will use shell processing to substitute shell environment variables, and will ignore any <code>CMD</code> or <code>docker run</code> command line arguments. To ensure that <code>docker stop</code> will signal any long running <code>ENTRYPOINT</code> executable correctly, you need to remember to start it with <code>exec</code>:</p>
<p>您可以为 ENTRYPOINT 指定一个纯字符串，它将在/bin/sh-c 中执行。此表单将使用 shell 处理来替换 shell 环境变量，并忽略任何 CMD 或 docker 运行的命令行参数。为了确保 docker 停止将正确地向任何长时间运行的 ENTRYPOINT 可执行文件发出信号，您需要记住使用 exec 启动它:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT exec top -b</span><br></pre></td></tr></table></figure>

<p>When you run this image, you’ll see the single <code>PID 1</code> process:</p>
<p>当你运行这个图片时，你会看到一个单独的 PID 1进程:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm --name <span class="built_in">test</span> top</span></span><br><span class="line"></span><br><span class="line">Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached</span><br><span class="line">CPU:   5% usr   0% sys   0% nic  94% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.08 0.03 0.05 2/98 6</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class="line">    1     0 root     R     3164   0%   0% top -b</span><br></pre></td></tr></table></figure>

<p>Which exits cleanly on <code>docker stop</code>:</p>
<p>它在码头停靠站上清晰地退出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /usr/bin/time docker stop <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line">test</span><br><span class="line">real	0m 0.20s</span><br><span class="line">user	0m 0.02s</span><br><span class="line">sys	0m 0.04s</span><br></pre></td></tr></table></figure>

<p>If you forget to add <code>exec</code> to the beginning of your <code>ENTRYPOINT</code>:</p>
<p>如果您忘记在 ENTRYPOINT 的开头添加 exec:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT top -b</span><br><span class="line">CMD --ignored-param1</span><br></pre></td></tr></table></figure>

<p>You can then run it (giving it a name for the next step):</p>
<p>然后你可以运行它(给它一个下一步的名字) :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --name <span class="built_in">test</span> top --ignored-param2</span></span><br><span class="line"></span><br><span class="line">Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached</span><br><span class="line">CPU:   9% usr   2% sys   0% nic  88% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.01 0.02 0.05 2/101 7</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class="line">    1     0 root     S     3168   0%   0% /bin/sh -c top -b cmd cmd2</span><br><span class="line">    7     1 root     R     3164   0%   0% top -b</span><br></pre></td></tr></table></figure>

<p>You can see from the output of <code>top</code> that the specified <code>ENTRYPOINT</code> is not <code>PID 1</code>.</p>
<p>从 top 的输出可以看到，指定的 ENTRYPOINT 不是 PID 1。</p>
<p>If you then run <code>docker stop test</code>, the container will not exit cleanly - the <code>stop</code> command will be forced to send a <code>SIGKILL</code> after the timeout:</p>
<p>如果然后运行 docker stop test，容器不会干净地退出——超时后 stop 命令将被迫发送一个 SIGKILL:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it <span class="built_in">test</span> ps aux</span></span><br><span class="line"></span><br><span class="line">PID   USER     COMMAND</span><br><span class="line">    1 root     /bin/sh -c top -b cmd cmd2</span><br><span class="line">    7 root     top -b</span><br><span class="line">    8 root     ps aux</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> /usr/bin/time docker stop <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line">test</span><br><span class="line">real	0m 10.19s</span><br><span class="line">user	0m 0.04s</span><br><span class="line">sys	0m 0.03s</span><br></pre></td></tr></table></figure>

<h3 id="Understand-how-CMD-and-ENTRYPOINT-interact-了解-CMD-和-ENTRYPOINT-如何相互作用"><a href="#Understand-how-CMD-and-ENTRYPOINT-interact-了解-CMD-和-ENTRYPOINT-如何相互作用" class="headerlink" title="Understand how CMD and ENTRYPOINT interact 了解 CMD 和 ENTRYPOINT 如何相互作用"></a>Understand how CMD and ENTRYPOINT interact 了解 CMD 和 ENTRYPOINT 如何相互作用</h3><p>Both <code>CMD</code> and <code>ENTRYPOINT</code> instructions define what command gets executed when running a container. There are few rules that describe their co-operation.</p>
<p>CMD 和 ENTRYPOINT 指令都定义了在运行容器时执行什么命令。几乎没有什么规则可以描述他们的合作。</p>
<ol>
<li><p>Dockerfile should specify at least one of <code>CMD</code> or <code>ENTRYPOINT</code> commands.</p>
<p>Dockerfile 应该指定至少一个 CMD 或 ENTRYPOINT 命令。</p>
</li>
<li><p><code>ENTRYPOINT</code> should be defined when using the container as an executable.</p>
<p>使用容器作为可执行文件时，应该定义 ENTRYPOINT。</p>
</li>
<li><p><code>CMD</code> should be used as a way of defining default arguments for an <code>ENTRYPOINT</code> command or for executing an ad-hoc command in a container.</p>
<p>CMD 应该用作定义 ENTRYPOINT 命令或在容器中执行临时命令的默认参数的一种方式。</p>
</li>
<li><p><code>CMD</code> will be overridden when running the container with alternative arguments.</p>
<p>当使用其他参数运行容器时，CMD 将被重写。</p>
</li>
</ol>
<p>The table below shows what command is executed for different <code>ENTRYPOINT</code> / <code>CMD</code> combinations:</p>
<p>下表显示了对不同的 ENTRYPOINT/CMD 组合执行的命令:</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">No ENTRYPOINT 没有入口点</th>
<th align="left">ENTRYPOINT exec_entry p1_entry 条目 p1条目</th>
<th align="left">ENTRYPOINT [“exec_entry”, “p1_entry”] ENTRYPOINT [“ exec _ entry” ，“ p1 _ entry”]</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>No CMD 没有 CMD</strong></td>
<td align="left"><em>error, not allowed 错误，不允许</em></td>
<td align="left">/bin/sh -c exec_entry p1_entry /bin/sh-c exec _ entry p1 _ entry</td>
<td align="left">exec_entry p1_entry 1/entry</td>
</tr>
<tr>
<td align="left"><strong>CMD [“exec_cmd”, “p1_cmd”] [“ exec _ CMD” ，“ p1 _ CMD”]</strong></td>
<td align="left">exec_cmd p1_cmd 1/cmd/cmd</td>
<td align="left">/bin/sh -c exec_entry p1_entry /bin/sh-c exec _ entry p1 _ entry</td>
<td align="left">exec_entry p1_entry exec_cmd p1_cmd 1/entry exec/cmd p1/cmd</td>
</tr>
<tr>
<td align="left"><strong>CMD [“p1_cmd”, “p2_cmd”] “ p1_cmd” ，“ p2_cmd”]</strong></td>
<td align="left">p1_cmd p2_cmd 1/cmd/2/cmd</td>
<td align="left">/bin/sh -c exec_entry p1_entry /bin/sh-c exec _ entry p1 _ entry</td>
<td align="left">exec_entry p1_entry p1_cmd p2_cmd 1 entry p1/1/cmd p2/cmd</td>
</tr>
<tr>
<td align="left"><strong>CMD exec_cmd p1_cmd 1/CMD</strong></td>
<td align="left">/bin/sh -c exec_cmd p1_cmd /bin/sh-c exec _ cmd p1 _ cmd</td>
<td align="left">/bin/sh -c exec_entry p1_entry /bin/sh-c exec _ entry p1 _ entry</td>
<td align="left">exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd Exec _ entry p1 _ entry/bin/sh-c exec _ cmd p1 _ cmd</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Note</strong></p>
<p>注意</p>
<p>If <code>CMD</code> is defined from the base image, setting <code>ENTRYPOINT</code> will reset <code>CMD</code> to an empty value. In this scenario, <code>CMD</code> must be defined in the current image to have a value.</p>
<p>如果从基本映像定义 CMD，则设置 ENTRYPOINT 将把 CMD 重置为空值。在这个场景中，CMD 必须在当前映像中定义才能有一个值。</p>
</blockquote>
<h2 id="VOLUME-体积"><a href="#VOLUME-体积" class="headerlink" title="VOLUME 体积"></a>VOLUME 体积</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME ["/data"]</span><br></pre></td></tr></table></figure>

<p>The <code>VOLUME</code> instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers. The value can be a JSON array, <code>VOLUME [&quot;/var/log/&quot;]</code>, or a plain string with multiple arguments, such as <code>VOLUME /var/log</code> or <code>VOLUME /var/log /var/db</code>. For more information/examples and mounting instructions via the Docker client, refer to <a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener"><em>Share Directories via Volumes</em></a> documentation.</p>
<p>VOLUME 指令创建具有指定名称的挂载点，并将其标记为保存来自本机主机或其他容器的外部挂载的卷。这个值可以是 JSON 数组、 VOLUME [”/var/log/”] ，或具有多个参数的普通字符串，如 VOLUME/var/log 或 VOLUME/var/log/var/var/db。有关更多信息/示例和通过 Docker 客户端安装说明，请参阅通过卷文档共享目录。</p>
<p>The <code>docker run</code> command initializes the newly created volume with any data that exists at the specified location within the base image. For example, consider the following Dockerfile snippet:</p>
<p>Docker run 命令使用基本映像中指定位置的任何数据初始化新创建的卷。例如，考虑下面的 Dockerfile 片段:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN mkdir /myvol</span><br><span class="line">RUN echo "hello world" &gt; /myvol/greeting</span><br><span class="line">VOLUME /myvol</span><br></pre></td></tr></table></figure>

<p>This Dockerfile results in an image that causes <code>docker run</code> to create a new mount point at <code>/myvol</code> and copy the <code>greeting</code> file into the newly created volume.</p>
<p>这个 Dockerfile 会生成一个映像，导致 docker 在/myvol 创建一个新的挂载点，并将问候文件复制到新创建的卷中。</p>
<h3 id="Notes-about-specifying-volumes-关于指定卷的注释"><a href="#Notes-about-specifying-volumes-关于指定卷的注释" class="headerlink" title="Notes about specifying volumes 关于指定卷的注释"></a>Notes about specifying volumes 关于指定卷的注释</h3><p>Keep the following things in mind about volumes in the <code>Dockerfile</code>.</p>
<p>关于 Dockerfile 中的卷，请记住以下内容。</p>
<ul>
<li><p><strong>Volumes on Windows-based containers</strong>: When using Windows-based containers, the destination of a volume inside the container must be one of:</p>
<p>基于 windows 的容器上的卷: 当使用基于 windows 的容器时，容器内的卷的目的地必须是:</p>
<ul>
<li>a non-existing or empty directory 不存在的或空的目录</li>
<li>a drive other than 除了开车<code>C:</code></li>
</ul>
</li>
<li><p><strong>Changing the volume from within the Dockerfile</strong>: If any build steps change the data within the volume after it has been declared, those changes will be discarded.</p>
<p>从 Dockerfile 中更改卷: 如果任何构建步骤在声明卷之后更改了卷中的数据，那么这些更改将被丢弃。</p>
</li>
<li><p><strong>JSON formatting</strong>: The list is parsed as a JSON array. You must enclose words with double quotes (<code>&quot;</code>) rather than single quotes (<code>&#39;</code>).</p>
<p>JSON 格式化: 列表被解析为 JSON 数组。必须用双引号(”)而不是单引号(’)括住单词。</p>
</li>
<li><p><strong>The host directory is declared at container run-time</strong>: The host directory (the mountpoint) is, by its nature, host-dependent. This is to preserve image portability, since a given host directory can’t be guaranteed to be available on all hosts. For this reason, you can’t mount a host directory from within the Dockerfile. The <code>VOLUME</code> instruction does not support specifying a <code>host-dir</code> parameter. You must specify the mountpoint when you create or run the container.</p>
<p>主机目录在容器运行时声明: 主机目录(挂载点)本质上是依赖于主机的。这是为了保持映像的可移植性，因为不能保证给定的主机目录在所有主机上都可用。由于这个原因，您不能从 Dockerfile 中挂载主机目录。VOLUME 指令不支持指定 host-dir 参数。在创建或运行容器时，必须指定挂载点。</p>
</li>
</ul>
<h2 id="USER-用户"><a href="#USER-用户" class="headerlink" title="USER 用户"></a>USER 用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER &lt;user&gt;[:&lt;group&gt;]</span><br></pre></td></tr></table></figure>

<p>or</p>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure>

<p>The <code>USER</code> instruction sets the user name (or UID) and optionally the user group (or GID) to use when running the image and for any <code>RUN</code>, <code>CMD</code> and <code>ENTRYPOINT</code> instructions that follow it in the <code>Dockerfile</code>.</p>
<p>USER 指令设置运行映像时要使用的用户名(或 UID)和可选的用户组(或 GID) ，以及 Dockerfile 中跟随它的任何 RUN、 CMD 和 ENTRYPOINT 指令。</p>
<blockquote>
<p>Note that when specifying a group for the user, the user will have <em>only</em> the specified group membership. Any other configured group memberships will be ignored.</p>
<p>请注意，在为用户指定组时，用户将只具有指定的组成员身份。任何其他配置的组成员关系都将被忽略。</p>
</blockquote>
<blockquote>
<p><strong>Warning</strong></p>
<p>警告</p>
<p>When the user doesn’t have a primary group then the image (or the next instructions) will be run with the <code>root</code> group.</p>
<p>当用户没有主组时，图像(或下一步指令)将与根组一起运行。</p>
<p>On Windows, the user must be created first if it’s not a built-in account. This can be done with the <code>net user</code> command called as part of a Dockerfile.</p>
<p>在 Windows 上，如果用户不是内置帐户，则必须首先创建用户。这可以通过作为 Dockerfile 的一部分调用的 net user 命令来完成。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"><span class="meta">#</span><span class="bash"> Create Windows user <span class="keyword">in</span> the container</span></span><br><span class="line">RUN net user /add patrick</span><br><span class="line"><span class="meta">#</span><span class="bash"> Set it <span class="keyword">for</span> subsequent commands</span></span><br><span class="line">USER patrick</span><br></pre></td></tr></table></figure>

<h2 id="WORKDIR-工作底线"><a href="#WORKDIR-工作底线" class="headerlink" title="WORKDIR 工作底线"></a>WORKDIR 工作底线</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure>

<p>The <code>WORKDIR</code> instruction sets the working directory for any <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>, <code>COPY</code> and <code>ADD</code> instructions that follow it in the <code>Dockerfile</code>. If the <code>WORKDIR</code> doesn’t exist, it will be created even if it’s not used in any subsequent <code>Dockerfile</code> instruction.</p>
<p>指令为任何在 Dockerfile 中跟随它的 RUN、 CMD、 ENTRYPOINT、 COPY 和 ADD 指令设置工作目录。如果 WORKDIR 不存在，即使它不在任何后续的 Dockerfile 指令中使用，它也会被创建。</p>
<p>The <code>WORKDIR</code> instruction can be used multiple times in a <code>Dockerfile</code>. If a relative path is provided, it will be relative to the path of the previous <code>WORKDIR</code> instruction. For example:</p>
<p>可以在 Dockerfile 中多次使用 WORKDIR 指令。如果提供了相对路径，那么它将相对于前面的 WORKDIR 指令的路径。例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>

<p>The output of the final <code>pwd</code> command in this <code>Dockerfile</code> would be <code>/a/b/c</code>.</p>
<p>这个 Dockerfile 中最终 pwd 命令的输出是/a/b/c。</p>
<p>The <code>WORKDIR</code> instruction can resolve environment variables previously set using <code>ENV</code>. You can only use environment variables explicitly set in the <code>Dockerfile</code>. For example:</p>
<p>WORKDIR 指令可以解析以前使用 ENV 设置的环境变量。您只能使用 Dockerfile 中显式设置的环境变量。例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV DIRPATH=/path</span><br><span class="line">WORKDIR $DIRPATH/$DIRNAME</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>

<p>The output of the final <code>pwd</code> command in this <code>Dockerfile</code> would be <code>/path/$DIRNAME</code></p>
<p>这个 Dockerfile 中最终 pwd 命令的输出是/path/$DIRNAME</p>
<h2 id="ARG-精氨酸脱氢酶"><a href="#ARG-精氨酸脱氢酶" class="headerlink" title="ARG 精氨酸脱氢酶"></a>ARG 精氨酸脱氢酶</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>

<p>The <code>ARG</code> instruction defines a variable that users can pass at build-time to the builder with the <code>docker build</code> command using the <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> flag. If a user specifies a build argument that was not defined in the Dockerfile, the build outputs a warning.</p>
<p>ARG 指令定义了一个变量，用户可以在构建时使用 docker build 命令使用 – build-ARG &lt; varname &gt; = &lt; value &gt; 标志将该变量传递给构建器。如果用户指定了未在 Dockerfile 中定义的构建参数，则构建将输出一个警告。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Warning] One or more build-args [foo] were not consumed.</span><br></pre></td></tr></table></figure>

<p>A Dockerfile may include one or more <code>ARG</code> instructions. For example, the following is a valid Dockerfile:</p>
<p>一个 Dockerfile 可能包含一个或多个 ARG 指令。例如，下面是一个有效的 Dockerfile:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ARG user1</span><br><span class="line">ARG buildno</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Warning:</strong></p>
<p>警告:</p>
<p>It is not recommended to use build-time variables for passing secrets like github keys, user credentials etc. Build-time variable values are visible to any user of the image with the <code>docker history</code> command.</p>
<p>建议不要使用构建时变量来传递诸如 github 密钥、用户凭证等秘密。使用 docker history 命令，构建时变量值对于图像的任何用户都是可见的。</p>
<p>Refer to the <a href="https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information" target="_blank" rel="noopener">“build images with BuildKit”</a> section to learn about secure ways to use secrets when building images.</p>
<p>请参阅“使用 BuildKit 构建映像”部分，了解在构建映像时使用秘密的安全方法。</p>
</blockquote>
<h3 id="Default-values-默认值"><a href="#Default-values-默认值" class="headerlink" title="Default values 默认值"></a>Default values 默认值</h3><p>An <code>ARG</code> instruction can optionally include a default value:</p>
<p>ARG 指令可以选择性地包含一个默认值:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ARG user1=someuser</span><br><span class="line">ARG buildno=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>

<p>If an <code>ARG</code> instruction has a default value and if there is no value passed at build-time, the builder uses the default.</p>
<p>如果 ARG 指令具有默认值，并且在构建时没有传递任何值，则构建器使用默认值。</p>
<h3 id="Scope-范围"><a href="#Scope-范围" class="headerlink" title="Scope 范围"></a>Scope 范围</h3><p>An <code>ARG</code> variable definition comes into effect from the line on which it is defined in the <code>Dockerfile</code> not from the argument’s use on the command-line or elsewhere. For example, consider this Dockerfile:</p>
<p>ARG 变量定义从在 Dockerfile 中定义它的行生效，而不是从在命令行或其他地方使用参数生效。例如，考虑这个 Dockerfile:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">USER $&#123;user:-some_user&#125;</span><br><span class="line">ARG user</span><br><span class="line">USER $user</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>

<p>A user builds this file by calling:</p>
<p>用户通过调用以下命令生成该文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build --build-arg user=what_user .</span></span><br></pre></td></tr></table></figure>

<p>The <code>USER</code> at line 2 evaluates to <code>some_user</code> as the <code>user</code> variable is defined on the subsequent line 3. The <code>USER</code> at line 4 evaluates to <code>what_user</code> as <code>user</code> is defined and the <code>what_user</code> value was passed on the command line. Prior to its definition by an <code>ARG</code> instruction, any use of a variable results in an empty string.</p>
<p>第2行的 USER 计算结果为某个 _ USER，因为用户变量是在后面的第3行定义的。第4行的 USER 计算结果为定义了什么 _ USER as USER，并且在命令行上传递了什么 _ USER 值。在 ARG 指令定义变量之前，变量的任何使用都会导致一个空字符串。</p>
<p>An <code>ARG</code> instruction goes out of scope at the end of the build stage where it was defined. To use an arg in multiple stages, each stage must include the <code>ARG</code> instruction.</p>
<p>ARG 指令在定义它的构建阶段结束时超出范围。要在多个阶段中使用 ARG，每个阶段都必须包含 ARG 指令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ARG SETTINGS</span><br><span class="line">RUN ./run/setup $SETTINGS</span><br><span class="line"></span><br><span class="line">FROM busybox</span><br><span class="line">ARG SETTINGS</span><br><span class="line">RUN ./run/other $SETTINGS</span><br></pre></td></tr></table></figure>

<h3 id="Using-ARG-variables-使用-ARG-变量"><a href="#Using-ARG-variables-使用-ARG-变量" class="headerlink" title="Using ARG variables 使用 ARG 变量"></a>Using ARG variables 使用 ARG 变量</h3><p>You can use an <code>ARG</code> or an <code>ENV</code> instruction to specify variables that are available to the <code>RUN</code> instruction. Environment variables defined using the <code>ENV</code> instruction always override an <code>ARG</code> instruction of the same name. Consider this Dockerfile with an <code>ENV</code> and <code>ARG</code> instruction.</p>
<p>您可以使用 ARG 或 ENV 指令来指定 RUN 指令可用的变量。使用 ENV 指令定义的环境变量总是重写同名的 ARG 指令。使用 ENV 和 ARG 指令考虑这个 Dockerfile。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER=v1.0.0</span><br><span class="line">RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure>

<p>Then, assume this image is built with this command:</p>
<p>然后，假设这个图像是用以下命令构建的:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build --build-arg CONT_IMG_VER=v2.0.1 .</span></span><br></pre></td></tr></table></figure>

<p>In this case, the <code>RUN</code> instruction uses <code>v1.0.0</code> instead of the <code>ARG</code> setting passed by the user:<code>v2.0.1</code> This behavior is similar to a shell script where a locally scoped variable overrides the variables passed as arguments or inherited from environment, from its point of definition.</p>
<p>在这种情况下，RUN 指令使用的是 v1.0.0，而不是用户传递的 ARG 设置: v2.0.1这种行为类似于 shell 脚本，其中局部作用域变量从定义的角度重写作为参数传递或从环境继承的变量。</p>
<p>Using the example above but a different <code>ENV</code> specification you can create more useful interactions between <code>ARG</code> and <code>ENV</code> instructions:</p>
<p>使用上面的例子，但是使用不同的 ENV 规范，你可以在 ARG 和 ENV 指令之间创建更有用的交互:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER=$&#123;CONT_IMG_VER:-v1.0.0&#125;</span><br><span class="line">RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure>

<p>Unlike an <code>ARG</code> instruction, <code>ENV</code> values are always persisted in the built image. Consider a docker build without the <code>--build-arg</code> flag:</p>
<p>与 ARG 指令不同，ENV 值始终保存在构建的映像中。考虑一个没有 – build-arg 标志的 docker 构建:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build .</span></span><br></pre></td></tr></table></figure>

<p>Using this Dockerfile example, <code>CONT_IMG_VER</code> is still persisted in the image but its value would be <code>v1.0.0</code> as it is the default set in line 3 by the <code>ENV</code> instruction.</p>
<p>使用这个 Dockerfile 示例，CONT _ img _ ver 仍然保存在图像中，但它的值为 v1.0.0，因为它是 ENV 指令在第3行中设置的默认值。</p>
<p>The variable expansion technique in this example allows you to pass arguments from the command line and persist them in the final image by leveraging the <code>ENV</code> instruction. Variable expansion is only supported for <a href="https://docs.docker.com/engine/reference/builder/#environment-replacement" target="_blank" rel="noopener">a limited set of Dockerfile instructions.</a></p>
<p>本例中的变量展开技术允许您从命令行传递参数，并通过利用 ENV 指令将它们持久化到最终映像中。变量扩展仅支持有限的一组 Dockerfile 指令。</p>
<h3 id="Predefined-ARGs-预定义的-ARGs"><a href="#Predefined-ARGs-预定义的-ARGs" class="headerlink" title="Predefined ARGs 预定义的 ARGs"></a>Predefined ARGs 预定义的 ARGs</h3><p>Docker has a set of predefined <code>ARG</code> variables that you can use without a corresponding <code>ARG</code> instruction in the Dockerfile.</p>
<p>Docker 有一组预定义的 ARG 变量，您可以在 Dockerfile 中不使用相应的 ARG 指令而使用它们。</p>
<ul>
<li><code>HTTP_PROXY</code></li>
<li><code>http_proxy</code></li>
<li><code>HTTPS_PROXY</code></li>
<li><code>https_proxy</code></li>
<li><code>FTP_PROXY</code></li>
<li><code>ftp_proxy</code></li>
<li><code>NO_PROXY</code></li>
<li><code>no_proxy</code></li>
</ul>
<p>To use these, simply pass them on the command line using the flag:</p>
<p>要使用它们，只需在命令行上使用标志传递它们:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--build-arg &lt;varname&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>

<p>By default, these pre-defined variables are excluded from the output of <code>docker history</code>. Excluding them reduces the risk of accidentally leaking sensitive authentication information in an <code>HTTP_PROXY</code> variable.</p>
<p>默认情况下，这些预定义的变量被排除在 docker 历史记录的输出之外。排除它们可以降低意外泄漏 httpproxy 变量中敏感的身份验证信息的风险。</p>
<p>For example, consider building the following Dockerfile using <code>--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com</code></p>
<p>例如，考虑使用-build-arg HTTP _ proxy = HTTP://user:<a href="mailto:pass@proxy.lon.example.com">pass@proxy.lon.example.com</a> 构建以下 Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN echo "Hello World"</span><br></pre></td></tr></table></figure>

<p>In this case, the value of the <code>HTTP_PROXY</code> variable is not available in the <code>docker history</code> and is not cached. If you were to change location, and your proxy server changed to <code>http://user:pass@proxy.sfo.example.com</code>, a subsequent build does not result in a cache miss.</p>
<p>在这种情况下，http_proxy 变量的值在 docker 历史记录中不可用，也不会被缓存。如果您要更改位置，并且您的代理服务器更改为 <a href="http://user:pass@proxy.sfo.example.com" target="_blank" rel="noopener">http://user:pass@proxy.sfo.example.com</a> 服务器，那么后续的构建不会导致缓存丢失。</p>
<p>If you need to override this behaviour then you may do so by adding an <code>ARG</code> statement in the Dockerfile as follows:</p>
<p>如果需要改变这种行为，可以在 Dockerfile 添加 ARG 语句，如下所示:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG HTTP_PROXY</span><br><span class="line">RUN echo "Hello World"</span><br></pre></td></tr></table></figure>

<p>When building this Dockerfile, the <code>HTTP_PROXY</code> is preserved in the <code>docker history</code>, and changing its value invalidates the build cache.</p>
<p>当构建这个 Dockerfile 时，HTTP _ proxy 保留在 docker 历史记录中，并且更改它的值会使构建缓存失效。</p>
<h3 id="Automatic-platform-ARGs-in-the-global-scope-全球范围内的自动平台-ARGs"><a href="#Automatic-platform-ARGs-in-the-global-scope-全球范围内的自动平台-ARGs" class="headerlink" title="Automatic platform ARGs in the global scope 全球范围内的自动平台 ARGs"></a>Automatic platform ARGs in the global scope 全球范围内的自动平台 ARGs</h3><p>This feature is only available when using the <a href="https://docs.docker.com/engine/reference/builder/#buildkit" target="_blank" rel="noopener">BuildKit</a> backend.</p>
<p>这个特性只有在使用 BuildKit 后端时才可用。</p>
<p>Docker predefines a set of <code>ARG</code> variables with information on the platform of the node performing the build (build platform) and on the platform of the resulting image (target platform). The target platform can be specified with the <code>--platform</code> flag on <code>docker build</code>.</p>
<p>Docker 预先定义了一组 ARG 变量，其中包含执行构建(构建平台)的节点平台和生成的图像平台(目标平台)上的信息。可以在 docker 构建中使用 – platform 标志指定目标平台。</p>
<p>The following <code>ARG</code> variables are set automatically:</p>
<p>下面的 ARG 变量是自动设置的:</p>
<ul>
<li><code>TARGETPLATFORM</code> - platform of the build result. Eg 建造结果的平台<code>linux/amd64</code>, <code>linux/arm/v7</code>, <code>windows/amd64</code>.</li>
<li><code>TARGETOS</code> - OS component of TARGETPLATFORM 目标平台的-操作系统组件</li>
<li><code>TARGETARCH</code> - architecture component of TARGETPLATFORM TARGETPLATFORM 体系结构组件</li>
<li><code>TARGETVARIANT</code> - variant component of TARGETPLATFORM 目标平台的变体组件</li>
<li><code>BUILDPLATFORM</code> - platform of the node performing the build. - 执行生成的节点的平台</li>
<li><code>BUILDOS</code> - OS component of BUILDPLATFORM BUILDPLATFORM 的-OS 组件</li>
<li><code>BUILDARCH</code> - architecture component of BUILDPLATFORM - BUILDPLATFORM 的体系结构组件</li>
<li><code>BUILDVARIANT</code> - variant component of BUILDPLATFORM BUILDPLATFORM 的-variant 组件</li>
</ul>
<p>These arguments are defined in the global scope so are not automatically available inside build stages or for your <code>RUN</code> commands. To expose one of these arguments inside the build stage redefine it without value.</p>
<p>这些参数是在全局范围内定义的，因此在构建阶段或 RUN 命令中不能自动使用。要在构建阶段中暴露这些参数之一，请在没有值的情况下重新定义它。</p>
<p>For example:</p>
<p>例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">ARG TARGETPLATFORM</span><br><span class="line">RUN echo "I'm building for $TARGETPLATFORM"</span><br></pre></td></tr></table></figure>

<h3 id="Impact-on-build-caching-对构建缓存的影响"><a href="#Impact-on-build-caching-对构建缓存的影响" class="headerlink" title="Impact on build caching 对构建缓存的影响"></a>Impact on build caching 对构建缓存的影响</h3><p><code>ARG</code> variables are not persisted into the built image as <code>ENV</code> variables are. However, <code>ARG</code> variables do impact the build cache in similar ways. If a Dockerfile defines an <code>ARG</code> variable whose value is different from a previous build, then a “cache miss” occurs upon its first usage, not its definition. In particular, all <code>RUN</code> instructions following an <code>ARG</code> instruction use the <code>ARG</code> variable implicitly (as an environment variable), thus can cause a cache miss. All predefined <code>ARG</code> variables are exempt from caching unless there is a matching <code>ARG</code> statement in the <code>Dockerfile</code>.</p>
<p>ARG 变量不会像 ENV 变量那样持久化到构建的映像中。然而，ARG 变量以类似的方式影响构建缓存。如果 Dockerfile 定义了一个 ARG 变量，它的值与前一个构建的值不同，那么在第一次使用时会出现“缓存错误” ，而不是在定义时。特别是，所有遵循 ARG 指令的 RUN 指令都隐式地使用 ARG 变量(作为一个环境变量) ，因此可能会导致缓存丢失。除非 Dockerfile 中有匹配的 ARG 语句，否则所有预定义的 ARG 变量都不进行缓存。</p>
<p>For example, consider these two Dockerfile:</p>
<p>例如，考虑以下两个 Dockerfile:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">RUN echo $CONT_IMG_VER</span><br><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure>

<p>If you specify <code>--build-arg CONT_IMG_VER=&lt;value&gt;</code> on the command line, in both cases, the specification on line 2 does not cause a cache miss; line 3 does cause a cache miss.<code>ARG CONT_IMG_VER</code> causes the RUN line to be identified as the same as running <code>CONT_IMG_VER=&lt;value&gt; echo hello</code>, so if the <code>&lt;value&gt;</code> changes, we get a cache miss.</p>
<p>如果您在命令行上指定 – build-arg CONT _ img _ ver = &lt; value &gt; ，那么在这两种情况下，第2行的规范都不会导致缓存错误; 第3行的确会导致缓存错误。</p>
<p>Consider another example under the same command line:</p>
<p>考虑同一命令行下的另一个例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER=$CONT_IMG_VER</span><br><span class="line">RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure>

<p>In this example, the cache miss occurs on line 3. The miss happens because the variable’s value in the <code>ENV</code> references the <code>ARG</code> variable and that variable is changed through the command line. In this example, the <code>ENV</code> command causes the image to include the value.</p>
<p>在本例中，第3行出现了缓存未命中的情况。之所以会发生遗漏，是因为 ENV 中变量的值引用了 ARG 变量，并且该变量通过命令行进行了更改。在这个示例中，ENV 命令使图像包含值。</p>
<p>If an <code>ENV</code> instruction overrides an <code>ARG</code> instruction of the same name, like this Dockerfile:</p>
<p>如果一个 ENV 指令覆盖了同名的 ARG 指令，比如这个 Dockerfile:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER=hello</span><br><span class="line">RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure>

<p>Line 3 does not cause a cache miss because the value of <code>CONT_IMG_VER</code> is a constant (<code>hello</code>). As a result, the environment variables and values used on the <code>RUN</code> (line 4) doesn’t change between builds.</p>
<p>第3行不会导致高速缓存丢失，因为 cont_img _ ver 的值是常量(hello)。因此，RUN (第4行)上使用的环境变量和值在构建之间不会更改。</p>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD &lt;INSTRUCTION&gt;</span><br></pre></td></tr></table></figure>

<p>The <code>ONBUILD</code> instruction adds to the image a <em>trigger</em> instruction to be executed at a later time, when the image is used as the base for another build. The trigger will be executed in the context of the downstream build, as if it had been inserted immediately after the <code>FROM</code> instruction in the downstream <code>Dockerfile</code>.</p>
<p>ONBUILD 指令向映像添加一个触发器指令，以便在以后将该映像用作另一个构建的基础时执行。触发器将在下游构建的上下文中执行，就好像它是在下游的 Dockerfile 中的 FROM 指令之后立即插入的一样。</p>
<p>Any build instruction can be registered as a trigger.</p>
<p>任何构建指令都可以注册为触发器。</p>
<p>This is useful if you are building an image which will be used as a base to build other images, for example an application build environment or a daemon which may be customized with user-specific configuration.</p>
<p>如果您正在构建一个映像，该映像将用作构建其他映像的基础，例如一个应用程序构建环境或一个守护进程，该守护进程可以使用特定于用户的配置进行自定义，那么这是非常有用的。</p>
<p>For example, if your image is a reusable Python application builder, it will require application source code to be added in a particular directory, and it might require a build script to be called <em>after</em> that. You can’t just call <code>ADD</code> and <code>RUN</code> now, because you don’t yet have access to the application source code, and it will be different for each application build. You could simply provide application developers with a boilerplate <code>Dockerfile</code> to copy-paste into their application, but that is inefficient, error-prone and difficult to update because it mixes with application-specific code.</p>
<p>例如，如果您的映像是一个可重用的 Python 应用程序构建器，则需要将应用程序源代码添加到特定的目录中，并且可能需要在此之后调用构建脚本。您现在不能只调用 ADD 和 RUN，因为您还没有访问应用程序源代码的权限，而且对于每个应用程序构建都是不同的。您可以简单地向应用程序开发人员提供一个样板文件 Dockerfile，以便将其复制粘贴到他们的应用程序中，但是这样做效率低下，容易出错，而且很难更新，因为它与特定于应用程序的代码混合在一起。</p>
<p>The solution is to use <code>ONBUILD</code> to register advance instructions to run later, during the next build stage.</p>
<p>解决方案是使用 ONBUILD 来注册预先指令，以便稍后在下一个构建阶段运行。</p>
<p>Here’s how it works:</p>
<p>以下是它的工作原理:</p>
<ol>
<li>When it encounters an 当它遇到一个<code>ONBUILD</code> instruction, the builder adds a trigger to the metadata of the image being built. The instruction does not otherwise affect the current build. 指令时，构建器将触发器添加到正在构建的映像的元数据中。否则，该指令不会影响当前的生成</li>
<li>At the end of the build, a list of all triggers is stored in the image manifest, under the key 在构建结束时，所有触发器的列表都存储在映像清单的 key 下面<code>OnBuild</code>. They can be inspected with the 。他们可以检查与<code>docker inspect</code> command. 命令</li>
<li>Later the image may be used as a base for a new build, using the 之后，该图像可以用作新构建的基础，使用<code>FROM</code> instruction. As part of processing the 作为处理指令的一部分<code>FROM</code> instruction, the downstream builder looks for 下游的建造者寻找<code>ONBUILD</code> triggers, and executes them in the same order they were registered. If any of the triggers fail, the 如果其中任何一个触发器失败，则按照它们注册的顺序执行<code>FROM</code> instruction is aborted which in turn causes the build to fail. If all triggers succeed, the 如果所有的触发器都成功，则<code>FROM</code> instruction completes and the build continues as usual. 指令完成，构建照常进行</li>
<li>Triggers are cleared from the final image after being executed. In other words they are not inherited by “grand-children” builds. 触发器在执行后从最终映像中清除。换句话说，它们不会被“子级”构建继承</li>
</ol>
<p>For example you might add something like this:</p>
<p>例如，你可以这样添加:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Warning</strong></p>
<p>警告</p>
<p>Chaining <code>ONBUILD</code> instructions using <code>ONBUILD ONBUILD</code> isn’t allowed.</p>
<p>不允许使用 ONBUILD ONBUILD 链接 ONBUILD 指令。</p>
</blockquote>
<blockquote>
<p><strong>Warning</strong></p>
<p>警告</p>
<p>The <code>ONBUILD</code> instruction may not trigger <code>FROM</code> or <code>MAINTAINER</code> instructions.</p>
<p>ONBUILD 指令不能触发 FROM 或 MAINTAINER 指令。</p>
</blockquote>
<h2 id="STOPSIGNAL-停止信号"><a href="#STOPSIGNAL-停止信号" class="headerlink" title="STOPSIGNAL 停止信号"></a>STOPSIGNAL 停止信号</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure>

<p>The <code>STOPSIGNAL</code> instruction sets the system call signal that will be sent to the container to exit. This signal can be a valid unsigned number that matches a position in the kernel’s syscall table, for instance 9, or a signal name in the format SIGNAME, for instance SIGKILL.</p>
<p>STOPSIGNAL 指令设置将被发送到容器退出的系统调用信号。这个信号可以是一个有效的无符号数，它与内核系统调用表中的一个位置(例如9)匹配，也可以是一个格式为 SIGNAME 的信号名，例如 SIGKILL。</p>
<h2 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h2><p>The <code>HEALTHCHECK</code> instruction has two forms:</p>
<p>HEALTHCHECK 指令有两种形式:</p>
<ul>
<li><code>HEALTHCHECK [OPTIONS] CMD command</code> (check container health by running a command inside the container) (通过在容器中运行命令检查容器的健康状况)</li>
<li><code>HEALTHCHECK NONE</code> (disable any healthcheck inherited from the base image) (禁用从基本图像继承的任何健康检查)</li>
</ul>
<p>The <code>HEALTHCHECK</code> instruction tells Docker how to test a container to check that it is still working. This can detect cases such as a web server that is stuck in an infinite loop and unable to handle new connections, even though the server process is still running.</p>
<p>HEALTHCHECK 指令告诉 Docker 如何测试容器以检查它是否仍在工作。这可以检测到一些情况，比如 web 服务器陷入无限循环，无法处理新的连接，即使服务器进程仍在运行。</p>
<p>When a container has a healthcheck specified, it has a <em>health status</em> in addition to its normal status. This status is initially <code>starting</code>. Whenever a health check passes, it becomes <code>healthy</code> (whatever state it was previously in). After a certain number of consecutive failures, it becomes <code>unhealthy</code>.</p>
<p>当一个容器具有指定的 healthcheck 时，它除了正常状态之外还具有一个健康状态。这个状态最初开始。每当健康检查通过，它就变得健康(无论它以前处于什么状态)。在一定数量的连续失败之后，它会变得不健康。</p>
<p>The options that can appear before <code>CMD</code> are:</p>
<p>可以出现在 CMD 之前的选项是:</p>
<ul>
<li><code>--interval=DURATION</code> (default: (默认值:<code>30s</code>)</li>
<li><code>--timeout=DURATION</code> (default: (默认值:<code>30s</code>)</li>
<li><code>--start-period=DURATION</code> (default: (默认值:<code>0s</code>)</li>
<li><code>--retries=N</code> (default: (默认值:<code>3</code>)</li>
</ul>
<p>The health check will first run <strong>interval</strong> seconds after the container is started, and then again <strong>interval</strong> seconds after each previous check completes.</p>
<p>运行状况检查将首先在容器启动后运行间隔秒，然后在每次前一次检查完成后再次运行间隔秒。</p>
<p>If a single run of the check takes longer than <strong>timeout</strong> seconds then the check is considered to have failed.</p>
<p>如果一次检查的运行时间超过超时秒，则认为该检查失败。</p>
<p>It takes <strong>retries</strong> consecutive failures of the health check for the container to be considered <code>unhealthy</code>.</p>
<p>如果容器被认为是不健康的，则需要重试连续的健康检查失败。</p>
<p><strong>start period</strong> provides initialization time for containers that need time to bootstrap. Probe failure during that period will not be counted towards the maximum number of retries. However, if a health check succeeds during the start period, the container is considered started and all consecutive failures will be counted towards the maximum number of retries.</p>
<p>启动周期为需要启动时间的容器提供初始化时间。在此期间的探测失败将不计入重试的最大次数。但是，如果健康检查在开始期间成功，则认为容器已启动，并且所有连续的失败都将计入重试的最大次数。</p>
<p>There can only be one <code>HEALTHCHECK</code> instruction in a Dockerfile. If you list more than one then only the last <code>HEALTHCHECK</code> will take effect.</p>
<p>Dockerfile 中只能有一条 HEALTHCHECK 指令。如果您列出了多于一个，那么只有最后一个 HEALTHCHECK 才会生效。</p>
<p>The command after the <code>CMD</code> keyword can be either a shell command (e.g. <code>HEALTHCHECK CMD /bin/check-running</code>) or an <em>exec</em> array (as with other Dockerfile commands; see e.g. <code>ENTRYPOINT</code> for details).</p>
<p>CMD 关键字后面的命令可以是 shell 命令(例如 HEALTHCHECK CMD/bin/check-running)或 exec 数组(例如其他 Dockerfile 命令; 参见 ENTRYPOINT)。</p>
<p>The command’s exit status indicates the health status of the container. The possible values are:</p>
<p>该命令的退出状态指示容器的健康状态。可能的值是:</p>
<ul>
<li>0: success - the container is healthy and ready for use 0: 成功-容器是健康的，并准备使用</li>
<li>1: unhealthy - the container is not working correctly 1: 不健康-容器不能正常工作</li>
<li>2: reserved - do not use this exit code 2: 保留-不要使用这个退出代码</li>
</ul>
<p>For example, to check every five minutes or so that a web-server is able to serve the site’s main page within three seconds:</p>
<p>例如，每五分钟左右检查一次网站服务器是否能够在三秒钟内提供网站的主页:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEALTHCHECK --interval=5m --timeout=3s \</span><br><span class="line">  CMD curl -f http://localhost/ || exit 1</span><br></pre></td></tr></table></figure>

<p>To help debug failing probes, any output text (UTF-8 encoded) that the command writes on stdout or stderr will be stored in the health status and can be queried with <code>docker inspect</code>. Such output should be kept short (only the first 4096 bytes are stored currently).</p>
<p>为了帮助调试失败的探测，命令在 stdout 或 stderr 上写入的任何输出文本(UTF-8编码)都将存储在健康状态中，并且可以通过 docker inspect 查询。这样的输出应该保持短(只有前4096字节当前存储)。</p>
<p>When the health status of a container changes, a <code>health_status</code> event is generated with the new status.</p>
<p>当容器的健康状态发生更改时，将生成一个带有新状态的 health_status 事件。</p>
<h2 id="SHELL-壳牌"><a href="#SHELL-壳牌" class="headerlink" title="SHELL 壳牌"></a>SHELL 壳牌</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL ["executable", "parameters"]</span><br></pre></td></tr></table></figure>

<p>The <code>SHELL</code> instruction allows the default shell used for the <em>shell</em> form of commands to be overridden. The default shell on Linux is <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>, and on Windows is <code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code>. The <code>SHELL</code> instruction <em>must</em> be written in JSON form in a Dockerfile.</p>
<p>SHELL 指令允许重写用于 SHELL 形式命令的默认 SHELL。Linux 上的默认 shell 是[”/bin/sh” ，”-c”] ，Windows 上的默认 shell 是[“ cmd” ，”/s” ，”/c”]。SHELL 指令必须在 Dockerfile 中以 JSON 格式编写。</p>
<p>The <code>SHELL</code> instruction is particularly useful on Windows where there are two commonly used and quite different native shells: <code>cmd</code> and <code>powershell</code>, as well as alternate shells available including <code>sh</code>.</p>
<p>SHELL 指令在 Windows 上特别有用，在 Windows 上有两个常用的、完全不同的本机 SHELL: cmd 和 powershell，以及可用的备用 SHELL，包括 sh。</p>
<p>The <code>SHELL</code> instruction can appear multiple times. Each <code>SHELL</code> instruction overrides all previous <code>SHELL</code> instructions, and affects all subsequent instructions. For example:</p>
<p>SHELL 指令可以出现多次。每个 SHELL 指令覆盖以前的所有 SHELL 指令，并影响以后的所有指令。例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Executed as cmd /S /C <span class="built_in">echo</span> default</span></span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Executed as cmd /S /C powershell -<span class="built_in">command</span> Write-Host default</span></span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Executed as powershell -<span class="built_in">command</span> Write-Host hello</span></span><br><span class="line">SHELL ["powershell", "-command"]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Executed as cmd /S /C <span class="built_in">echo</span> hello</span></span><br><span class="line">SHELL ["cmd", "/S", "/C"]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure>

<p>The following instructions can be affected by the <code>SHELL</code> instruction when the <em>shell</em> form of them is used in a Dockerfile: <code>RUN</code>, <code>CMD</code> and <code>ENTRYPOINT</code>.</p>
<p>当 Dockerfile 中使用 SHELL 指令时，下列指令可能会受到 SHELL 指令的影响: RUN、 CMD 和 ENTRYPOINT。</p>
<p>The following example is a common pattern found on Windows which can be streamlined by using the <code>SHELL</code> instruction:</p>
<p>下面的例子是 Windows 上的一个常见模式，可以使用 SHELL 指令进行简化:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN powershell -command Execute-MyCmdlet -param1 "c:\foo.txt"</span><br></pre></td></tr></table></figure>

<p>The command invoked by docker will be:</p>
<p>由 docker 调用的命令如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /S /C powershell -command Execute-MyCmdlet -param1 "c:\foo.txt"</span><br></pre></td></tr></table></figure>

<p>This is inefficient for two reasons. First, there is an un-necessary cmd.exe command processor (aka shell) being invoked. Second, each <code>RUN</code> instruction in the <em>shell</em> form requires an extra <code>powershell -command</code> prefixing the command.</p>
<p>这种做法效率低下有两个原因。首先，调用了一个不必要的 cmd.exe 命令处理器(即 shell)。其次，shell 表单中的每个 RUN 指令都需要一个额外的 powershell 命令，在命令前面加上前缀。</p>
<p>To make this more efficient, one of two mechanisms can be employed. One is to use the JSON form of the RUN command such as:</p>
<p>为了提高效率，可以采用两种机制之一。一种是使用 RUN 命令的 JSON 格式，例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN ["powershell", "-command", "Execute-MyCmdlet", "-param1 \"c:\\foo.txt\""]</span><br></pre></td></tr></table></figure>

<p>While the JSON form is unambiguous and does not use the un-necessary cmd.exe, it does require more verbosity through double-quoting and escaping. The alternate mechanism is to use the <code>SHELL</code> instruction and the <em>shell</em> form, making a more natural syntax for Windows users, especially when combined with the <code>escape</code> parser directive:</p>
<p>虽然 JSON 表单是明确的，并且没有使用不必要的 cmd.exe，但是通过双引号和转义确实需要更多的详细信息。另一种机制是使用 SHELL 指令和 SHELL 表单，为 Windows 用户创建更自然的语法，特别是当与 escape 解析器指令结合时:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> escape=`</span></span><br><span class="line"></span><br><span class="line">FROM microsoft/nanoserver</span><br><span class="line">SHELL ["powershell","-command"]</span><br><span class="line">RUN New-Item -ItemType Directory C:\Example</span><br><span class="line">ADD Execute-MyCmdlet.ps1 c:\example\</span><br><span class="line">RUN c:\example\Execute-MyCmdlet -sample 'hello world'</span><br></pre></td></tr></table></figure>

<p>Resulting in:</p>
<p>结果是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\build\shell&gt; docker build -t shell .</span><br><span class="line">Sending build context to Docker daemon 4.096 kB</span><br><span class="line">Step 1/5 : FROM microsoft/nanoserver</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 22738ff49c6d</span></span><br><span class="line">Step 2/5 : SHELL powershell -command</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 6fcdb6855ae2</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 6331462d4300</span></span><br><span class="line">Removing intermediate container 6fcdb6855ae2</span><br><span class="line">Step 3/5 : RUN New-Item -ItemType Directory C:\Example</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> d0eef8386e97</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Directory: C:\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">d-----       10/28/2016  11:26 AM                Example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 3f2fbf1395d9</span></span><br><span class="line">Removing intermediate container d0eef8386e97</span><br><span class="line">Step 4/5 : ADD Execute-MyCmdlet.ps1 c:\example\</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> a955b2621c31</span></span><br><span class="line">Removing intermediate container b825593d39fc</span><br><span class="line">Step 5/5 : RUN c:\example\Execute-MyCmdlet 'hello world'</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> be6d8e63fe75</span></span><br><span class="line">hello world</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 8e559e9bf424</span></span><br><span class="line">Removing intermediate container be6d8e63fe75</span><br><span class="line">Successfully built 8e559e9bf424</span><br><span class="line">PS E:\docker\build\shell&gt;</span><br></pre></td></tr></table></figure>

<p>The <code>SHELL</code> instruction could also be used to modify the way in which a shell operates. For example, using <code>SHELL cmd /S /C /V:ON|OFF</code> on Windows, delayed environment variable expansion semantics could be modified.</p>
<p>SHELL 指令也可以用来修改 SHELL 的操作方式。例如，在 Windows 上使用 SHELL cmd/s/c/v: ON | OFF，可以修改延迟的环境变量扩展语义。</p>
<p>The <code>SHELL</code> instruction can also be used on Linux should an alternate shell be required such as <code>zsh</code>, <code>csh</code>, <code>tcsh</code> and others.</p>
<p>如果需要其他 SHELL，比如 zsh、 csh、 tcsh 和其他，那么也可以在 Linux 上使用 SHELL 指令。</p>
<h2 id="External-implementation-features-外部实现特性"><a href="#External-implementation-features-外部实现特性" class="headerlink" title="External implementation features 外部实现特性"></a>External implementation features 外部实现特性</h2><p>This feature is only available when using the <a href="https://docs.docker.com/engine/reference/builder/#buildkit" target="_blank" rel="noopener">BuildKit</a> backend.</p>
<p>这个特性只有在使用 BuildKit 后端时才可用。</p>
<p>Docker build supports experimental features like cache mounts, build secrets and ssh forwarding that are enabled by using an external implementation of the builder with a syntax directive. To learn about these features, <a href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md" target="_blank" rel="noopener">refer to the documentation in BuildKit repository</a>.</p>
<p>Docker build 支持一些实验特性，比如缓存挂载、构建机密和 ssh 转发，这些特性是通过构建器的外部实现和语法指令来启用的。要了解这些特性，请参阅 BuildKit 存储库中的文档。</p>
<h2 id="Dockerfile-examples-文件例子"><a href="#Dockerfile-examples-文件例子" class="headerlink" title="Dockerfile examples 文件例子"></a>Dockerfile examples 文件例子</h2><p>Below you can see some examples of Dockerfile syntax.</p>
<p>下面你可以看到一些 Dockerfile 语法的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Nginx</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> VERSION               0.0.1</span></span><br><span class="line"></span><br><span class="line">FROM      ubuntu</span><br><span class="line">LABEL Description="This image is used to start the foobar executable" Vendor="ACME Products" Version="1.0"</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> Firefox over VNC</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> VERSION               0.3</span></span><br><span class="line"></span><br><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install vnc, xvfb <span class="keyword">in</span> order to create a <span class="string">'fake'</span> display and firefox</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span><br><span class="line">RUN mkdir ~/.vnc</span><br><span class="line"><span class="meta">#</span><span class="bash"> Setup a password</span></span><br><span class="line">RUN x11vnc -storepasswd 1234 ~/.vnc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> Autostart firefox (might not be the best way, but it does the trick)</span></span><br><span class="line">RUN bash -c 'echo "firefox" &gt;&gt; /.bashrc'</span><br><span class="line"></span><br><span class="line">EXPOSE 5900</span><br><span class="line">CMD    ["x11vnc", "-forever", "-usepw", "-create"]</span><br><span class="line"><span class="meta">#</span><span class="bash"> Multiple images example</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> VERSION               0.1</span></span><br><span class="line"></span><br><span class="line">FROM ubuntu</span><br><span class="line">RUN echo foo &gt; bar</span><br><span class="line"><span class="meta">#</span><span class="bash"> Will output something like ===&gt; 907ad6c2736f</span></span><br><span class="line"></span><br><span class="line">FROM ubuntu</span><br><span class="line">RUN echo moo &gt; oink</span><br><span class="line"><span class="meta">#</span><span class="bash"> Will output something like ===&gt; 695d7793cbe4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> You<span class="string">'ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /oink.</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.docker.com/search/?q=builder" target="_blank" rel="noopener">builder 建造者</a>, <a href="https://docs.docker.com/search/?q=docker" target="_blank" rel="noopener">docker 码头工人</a>, <a href="https://docs.docker.com/search/?q=Dockerfile" target="_blank" rel="noopener">Dockerfile 文档</a>, <a href="https://docs.docker.com/search/?q=automation" target="_blank" rel="noopener">automation 自动化</a>, [image creation 图像生成](<a href="https://docs.docker.com/search/?q=image" target="_blank" rel="noopener">https://docs.docker.com/search/?q=image</a> creation)</p>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          
          <li class="next">
            <a href="/2021/01/13/Distributed-link-tracking 实践/" data-toggle="tooltip" data-placement="top" title="分布式链路跟踪">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <div class="tip">
          <p>
            If you like this blog or find it useful for you, you are welcome to comment on it. You are also welcome to share this blog, so that more people can participate in it. If the images used in the blog infringe your copyright, please contact the author to delete them. Thank you !
          </p>
        </div>
        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=Dockerfile reference 中英文&body=Hi,I found this website and thought you might like it https://wangpaitech.github.io/2021/01/14/Dockerfile reference/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

<!-- gitalk start -->
<!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

<div id="gitalk-container"></div>

<!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
<script src="/js/comment/gitalk.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: '',
    owner: '',
    admin: '',
    id: 'Thu Jan 14 2021 14:57:36 GMT+0800', // Ensure uniqueness and length less than 50
    distractionFreeMode: false, // Facebook-like distraction free mode
    perPage: 10 ,
    pagerDirection: 'last',
    createIssueManually: false ,
    language: 'en'
  });
  gitalk.render('gitalk-container');

  var gtFolded = () => {
    setTimeout(function() {
      let markdownBody = document.getElementsByClassName("markdown-body");
      let list = Array.from(markdownBody);
      list.forEach(item => {
        if (item.clientHeight > 250) {
          item.classList.add('gt-comment-body-folded');
          item.style.maxHeight = '250px';
          item.title = 'Click to Expand';
          item.onclick = function() {
            item.classList.remove('gt-comment-body-folded');
            item.style.maxHeight = '';
            item.title = '';
            item.onclick = null;
          };
        }
      })
    }, 800);
  }
</script>

<!-- gitalk end -->



<!-- 2. gitment comment -->



<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Dockerfile-reference"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">Dockerfile reference</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#文档参考"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">文档参考</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Usage-用法"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">Usage 用法</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#BuildKit"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">BuildKit</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Format-格式"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">Format 格式</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Parser-directives-解析器指令"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">Parser directives 解析器指令</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#syntax-语法"><span class="toc-nav-number">2.5.</span> <span class="toc-nav-text">syntax 语法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Official-releases-官方发布"><span class="toc-nav-number">2.5.1.</span> <span class="toc-nav-text">Official releases 官方发布</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#escape-逃跑"><span class="toc-nav-number">2.6.</span> <span class="toc-nav-text">escape 逃跑</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Environment-replacement-环境更新"><span class="toc-nav-number">2.7.</span> <span class="toc-nav-text">Environment replacement 环境更新</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#dockerignore-file-dockerignore-文件"><span class="toc-nav-number">2.8.</span> <span class="toc-nav-text">.dockerignore file . dockerignore 文件</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#FROM-来自"><span class="toc-nav-number">2.9.</span> <span class="toc-nav-text">FROM 来自:</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Understand-how-ARG-and-FROM-interact-了解-ARG-和-FROM-是如何相互作用的"><span class="toc-nav-number">2.9.1.</span> <span class="toc-nav-text">Understand how ARG and FROM interact 了解 ARG 和 FROM 是如何相互作用的</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RUN-快跑"><span class="toc-nav-number">2.10.</span> <span class="toc-nav-text">RUN 快跑</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Known-issues-RUN-已知问题-RUN"><span class="toc-nav-number">2.10.1.</span> <span class="toc-nav-text">Known issues (RUN) 已知问题(RUN)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#CMD-中国医学博士学位"><span class="toc-nav-number">2.11.</span> <span class="toc-nav-text">CMD 中国医学博士学位</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#LABEL-标签"><span class="toc-nav-number">2.12.</span> <span class="toc-nav-text">LABEL 标签</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#MAINTAINER-deprecated-维护人员-已弃用"><span class="toc-nav-number">2.13.</span> <span class="toc-nav-text">MAINTAINER (deprecated) 维护人员(已弃用)</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#EXPOSE-曝光"><span class="toc-nav-number">2.14.</span> <span class="toc-nav-text">EXPOSE 曝光</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ENV-环境病毒"><span class="toc-nav-number">2.15.</span> <span class="toc-nav-text">ENV 环境病毒</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ADD-注意力缺乏症"><span class="toc-nav-number">2.16.</span> <span class="toc-nav-text">ADD 注意力缺乏症</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#COPY-收到"><span class="toc-nav-number">2.17.</span> <span class="toc-nav-text">COPY 收到</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ENTRYPOINT"><span class="toc-nav-number">2.18.</span> <span class="toc-nav-text">ENTRYPOINT</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Exec-form-ENTRYPOINT-example-Exec-形式的-ENTRYPOINT-示例"><span class="toc-nav-number">2.18.1.</span> <span class="toc-nav-text">Exec form ENTRYPOINT example Exec 形式的 ENTRYPOINT 示例</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Shell-form-ENTRYPOINT-example-Shell-表单-ENTRYPOINT-示例"><span class="toc-nav-number">2.18.2.</span> <span class="toc-nav-text">Shell form ENTRYPOINT example Shell 表单 ENTRYPOINT 示例</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Understand-how-CMD-and-ENTRYPOINT-interact-了解-CMD-和-ENTRYPOINT-如何相互作用"><span class="toc-nav-number">2.18.3.</span> <span class="toc-nav-text">Understand how CMD and ENTRYPOINT interact 了解 CMD 和 ENTRYPOINT 如何相互作用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#VOLUME-体积"><span class="toc-nav-number">2.19.</span> <span class="toc-nav-text">VOLUME 体积</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Notes-about-specifying-volumes-关于指定卷的注释"><span class="toc-nav-number">2.19.1.</span> <span class="toc-nav-text">Notes about specifying volumes 关于指定卷的注释</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#USER-用户"><span class="toc-nav-number">2.20.</span> <span class="toc-nav-text">USER 用户</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WORKDIR-工作底线"><span class="toc-nav-number">2.21.</span> <span class="toc-nav-text">WORKDIR 工作底线</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ARG-精氨酸脱氢酶"><span class="toc-nav-number">2.22.</span> <span class="toc-nav-text">ARG 精氨酸脱氢酶</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Default-values-默认值"><span class="toc-nav-number">2.22.1.</span> <span class="toc-nav-text">Default values 默认值</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Scope-范围"><span class="toc-nav-number">2.22.2.</span> <span class="toc-nav-text">Scope 范围</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Using-ARG-variables-使用-ARG-变量"><span class="toc-nav-number">2.22.3.</span> <span class="toc-nav-text">Using ARG variables 使用 ARG 变量</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Predefined-ARGs-预定义的-ARGs"><span class="toc-nav-number">2.22.4.</span> <span class="toc-nav-text">Predefined ARGs 预定义的 ARGs</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Automatic-platform-ARGs-in-the-global-scope-全球范围内的自动平台-ARGs"><span class="toc-nav-number">2.22.5.</span> <span class="toc-nav-text">Automatic platform ARGs in the global scope 全球范围内的自动平台 ARGs</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Impact-on-build-caching-对构建缓存的影响"><span class="toc-nav-number">2.22.6.</span> <span class="toc-nav-text">Impact on build caching 对构建缓存的影响</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ONBUILD"><span class="toc-nav-number">2.23.</span> <span class="toc-nav-text">ONBUILD</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#STOPSIGNAL-停止信号"><span class="toc-nav-number">2.24.</span> <span class="toc-nav-text">STOPSIGNAL 停止信号</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#HEALTHCHECK-健康检查"><span class="toc-nav-number">2.25.</span> <span class="toc-nav-text">HEALTHCHECK 健康检查</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#SHELL-壳牌"><span class="toc-nav-number">2.26.</span> <span class="toc-nav-text">SHELL 壳牌</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#External-implementation-features-外部实现特性"><span class="toc-nav-number">2.27.</span> <span class="toc-nav-text">External implementation features 外部实现特性</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Dockerfile-examples-文件例子"><span class="toc-nav-number">2.28.</span> <span class="toc-nav-text">Dockerfile examples 文件例子</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    


      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">FEATURED TAGS</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#Docker" title="Docker">Docker</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
        <hr>
        <h5>FRIENDS</h5>
        <ul class="list-inline">

          
          <li>
            <a href="https://v-vincen.life/" target="_blank">V_Vincen</a>
          </li>
          
          <li>
            <a href="http://beantech.org" target="_blank">Bean Tech</a>
          </li>
          
          <li>
            <a href="http://huangxuan.me" target="_blank">Hux Blog</a>
          </li>
          
          <li>
            <a href="https://hexo.io/" target="_blank">Hexo</a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



	<!-- Footer (contains ThemeColor、viewer) -->
	<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/V-Vincen">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          
            <li>
              <a target="_blank" href="https://twitter.com/V_Vincen_">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          
            <li>
              <a target="_blank" href="https://www.instagram.com/v_vincen_">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          
            <li>
              <a target="_blank" href="http://weibo.com/WVincen">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          Chen Jianfei
          2021
          <br>
          Theme by
          <a href="http://beantech.org" target="_blank" rel="noopener">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a href="https://v-vincen.life/" target="_blank" rel="noopener">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>

<!-- jQuery -->
<script type="text/javascript" src="/js/jquery.min.js"></script>
<!-- <script type="text/javascript" src="/js/jquery.js"></script> -->
<!-- <script type="text/javascript" src="//cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script> -->

<!-- Bootstrap Core JavaScript -->
<script type="text/javascript" src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script type="text/javascript" src="/js/hux-blog.min.js"></script>

<!-- catalog -->
<script type="text/javascript" async="true" src="/js/catalog.js?v=1.0.0"></script>

<!-- totop(rocket) -->
<script type="text/javascript" async="true" src="/js/totop.js?v=1.0.0"></script>

<!-- Busuanzi JavaScript -->
<script type="text/javascript" async="true" src="/js/busuanzi.pure.mini.js"></script>


  <!-- Scroll start -->
  <script type="text/javascript" src="/js/scroll.js"></script>
  <!-- Scroll end -->



  <!-- ThemeColor start -->
  <script type="text/javascript" src="/js/themecolor.js"></script>
  <!-- ThemeColor end -->





  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  <script type="text/javascript" src="/js/viewer/viewer.min.js"></script>
  <script type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){ hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if($('#tag_cloud').length !== 0){ async("https://wangpaitech.github.io/js/jquery.tagcloud.js",function(){ $.fn.tagcloud.defaults = { //size: {start: 1, end: 1, unit: 'em'}, color: {start:
'#bbbbee', end: '#0085a1'}, }; $('#tag_cloud a').tagcloud(); }) } </script> -->


	<!-- Search -->
	
	<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  <script src="/js/ziploader.js"></script>
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;

            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


	

	<!-- Image to hack wechat -->
	<!-- <img src="https://wangpaitech.github.io/img/icon_wechat.png" width="0" height="0" /> -->
	<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
